#  Problemas de TWFE y alternativas modernas en DiD

##  Contexto r√°pido {-}

* **¬øQu√© ver√°s?** C√≥mo se comporta el estimador **TWFE** (two-way fixed effects) en distintos escenarios de DiD: 2√ó2, panel largo, m√°s de dos unidades con **heterogeneidad de efectos**, y **adopci√≥n escalonada**.
* **¬øPor qu√© importa?** Con heterogeneidad y/o timing escalonado, TWFE puede promediar **mal** (incluso con **pesos negativos**), sesgando el estimador.
* **¬øC√≥mo lo detectamos?** Con la **descomposici√≥n de Bacon** y estudios de eventos.
* **¬øQu√© alternativas hay?** Estimadores modernos: **CSDID (Callaway & Sant‚ÄôAnna)**, **did\_imputation (BJS)**, **eventstudyinteract (Sun & Abraham)**, **did\_multiplegt**, **did2s**, **stackedev**, etc.

> üí° **Nota de ejecuci√≥n**: Algunas secciones usan comandos/paquetes de SSC. Debes instalarlos al menos una vez (abajo incluyo la instalaci√≥n con `ssc install ‚Ä¶, replace`).

---

## Modelo b√°sico 2√ó2 DiD {-}

### Explicaci√≥n did√°ctica {-}

* Construimos un panel simple con **2 unidades** (`id = 1,2`) y **2 periodos** (`t = 1979, 1980`).
* Tratamiento **solo** para `id==2` en el **a√±o final** (`D = 1` si `id==2 & t==fin`).
* Generamos un outcome `Y` con nivel por unidad (`id`), tendencia temporal (`3*t`) y un ‚Äúempuj√≥n‚Äù de tratamiento cuando `D==1` (`tau=2`).
* Graficamos la evoluci√≥n de `Y` por grupo (control vs tratado).
* Estimamos DiD con:

  * `xtreg Y D t, fe` (FE de unidad + control lineal por `t`), y
  * `reghdfe Y D, absorb(id t)` (FE completos de unidad y de tiempo).

### C√≥digo (copiar/pegar)

```stata
*----------------------------------------------------------
* Archivo DO: TWFE y Diferencias en Diferencias (DiD)
*  modelo TWFE, DiD y Triple DiD
* Autor: Ana Maria Diaz
* ----------------------------------------------------------

* -------------------------
* 1. Modelo b√°sico 2x2 DiD
* -------------------------

clear
* Definir par√°metros flexibles
local unidades = 2
local inicio = 1979
local fin    = 1980

local tiempo = `fin' - `inicio' + 1
local obs    = `unidades' * `tiempo'
set obs `obs'

* Crear variables id y t (compatibles con a√±os)
gen id = .
gen t  = .

forvalues i = 1/`unidades' {
    forvalues j = 0/`=`tiempo'-1' {
        local obsnum = (`i' - 1)*`tiempo' + `j' + 1
        replace id = `i' in `obsnum'
        replace t  = `inicio' + `j' in `obsnum'
    }
}

sort id t
xtset id t

label variable id "Unidad"
label variable t  "A√±o"

* Generar tratamiento (id==2 tratado en a√±o final)
gen D = id==2 & t==`fin'
label variable D "Tratamiento (id==2 en a√±o final)"

* Efecto del tratamiento
gen tau = cond(D==1, 2, 0)
gen Y = id + 3*t + tau*D 
*gen Y = id + 3*t + tau*D + rnormal()
label variable Y "Variable dependiente"

twoway ///
  (connected Y t if id==1, msymbol(circle) lcolor(blue)) ///
  (connected Y t if id==2, msymbol(triangle) lcolor(red)) ///
  , ///
  title("Evoluci√≥n de Y: Control vs Tratado") ///
  xtitle("A√±o") ytitle("Y") ///
  xlabel(`inicio'(1)`fin') ///
  legend(order(1 "Control (id=1)" 2 "Tratado (id=2)")) ///
  name(grafico1, replace)

```
![Evoluci√≥n de Y](dofile/11_TWFE/g1.png)

```stata
* Estimar DiD con efectos fijos
xtreg Y D t, fe

* Alternativa con reghdfe
reghdfe Y D, absorb(id t)
```

---

## Panel largo con 2 unidades y tratamiento ‚Äúdesde un a√±o en adelante‚Äù {-}

* Mantenemos **2 unidades**, pero ampliamos a **1980‚Äì1990** (11 a√±os).
* Tratamiento para `id==2` **desde 1985 en adelante** (escal√≥n).
* Outcome `Y` con nivel por unidad + tendencia temporal + efecto de tratamiento (`tau=5`).
* Estimamos `xtreg`/`reghdfe` y **DiD oficial** (`xtdidreg`) con diagn√≥sticos de tendencias (`estat trendplots`, `estat ptrends`).


```stata
* ---------------------------------------------
* 2. A√±adir m√°s periodos de tiempo (10 por unidad)
* ---------------------------------------------

clear
local unidades = 2
local inicio = 1980
local fin    = 1990

local tiempo = `fin' - `inicio' + 1
local obs    = `unidades' * `tiempo'
set obs `obs'

* Crear variables id y t (funciona con a√±os)
gen id = .
gen t  = .

forvalues i = 1/`unidades' {
    forvalues j = 0/`=`tiempo'-1' {
        local obsnum = (`i' - 1)*`tiempo' + `j' + 1
        replace id = `i' in `obsnum'
        replace t  = `inicio' + `j' in `obsnum'
    }
}

sort id t
xtset id t

* Tratamiento desde cierto a√±o en adelante para id==2
gen D = id==2 & t >= 1985  // ejemplo: tratamiento inicia en 1985
label variable D "Tratado"

* Efecto del tratamiento
gen tau = cond(D==1, 5, 0)
gen Y = id + 3*t + tau*D
label variable Y "Variable dependiente"

*Visualizar
twoway ///
  (connected Y t if id==1, msymbol(circle) lcolor(blue)) ///
  (connected Y t if id==2, msymbol(triangle) lcolor(red)) ///
  , ///
  title("Evoluci√≥n de Y: Tratado vs. Control") ///
  xlabel(`inicio'(1)`fin') ///
  ylabel(, angle(horizontal)) ///
  xtitle("A√±o") ///
  ytitle("Y") ///
  legend(order(1 "Control (id=1)" 2 "Tratado (id=2)")) ///
  name(graficoY, replace)


xtreg Y D t, fe
reghdfe Y D, absorb(id t)

xtdidreg (Y) (D), group(id) time(t)
estat trendplots
estat ptrends
```

![Evoluci√≥n de Y](dofile/11_TWFE/g2.png)
![TendeciasParalelas](dofile/11_TWFE/g3.png)

---

## M√°s unidades, **mismo** a√±o de inicio, **efectos heterog√©neos** {-}

### Versi√≥n donde `Y` refleja solo el tama√±o del efecto por tratado {-}

* **3 unidades** (id 1=control; id 2 y 3 tratados desde 1985), con **distinto tama√±o de efecto**: 2 vs 4.
* Muestra que TWFE hace un **promedio no trivial** de estos efectos.

```stata
* --------------------------------------------------
* 3. M√°s unidades, mismo tiempo de tratamiento, distinto efecto
* --------------------------------------------------

clear
* Par√°metros flexibles
local unidades = 3
local inicio = 1980
local fin    = 1989

local tiempo = `fin' - `inicio' + 1
local obs = `unidades' * `tiempo'
set obs `obs'

* Crear variables id y t (con a√±os reales)
gen id = .
gen t  = .

forvalues i = 1/`unidades' {
    forvalues j = 0/`=`tiempo'-1' {
        local obsnum = (`i' - 1)*`tiempo' + `j' + 1
        replace id = `i' in `obsnum'
        replace t  = `inicio' + `j' in `obsnum'
    }
}

sort id t
xtset id t

* Tratamiento para id >= 2 desde t >= 1985
gen D = 0
replace D = 1 if id >= 2 & t >= 1985
label variable D "Tratado desde 1985 para id>=2"

* Variable dependiente con diferentes intensidades de tratamiento
cap drop Y
gen Y = 0
replace Y = cond(D == 1, 2, 0) if id == 2
replace Y = cond(D == 1, 4, 0) if id == 3
label variable Y "Variable dependiente"
sum Y if  D == 1

* -------------------------------
* Visualizaci√≥n
* -------------------------------
twoway ///
  (connected Y t if id == 1, msymbol(circle)) ///
  (connected Y t if id == 2, msymbol(triangle)) ///
  (connected Y t if id == 3, msymbol(square)) ///
  , ///
  xline(1985, lpattern(dash)) ///
  xlabel(`inicio'(1)`fin') ///
  legend(order(1 "id=1 (Control)" 2 "id=2 (Tratado - efecto 2)" 3 "id=3 (Tratado - efecto 4)")) ///
  title("Efectos de distinto tama√±o") ///
  xtitle("A√±o") ///
  ytitle("Y")

* -------------------------------
* Estimaci√≥n
* -------------------------------
xtreg Y D t, fe

* Comparaci√≥n con especificaciones alternativas
reg Y D                       // sin efectos fijos
reg Y D i.t                   // solo efectos fijos de tiempo
reg Y D i.id                  // solo efectos fijos de unidad
reg Y D i.t i.id              // ambos (especificaci√≥n correcta)
```
![Grafico](dofile/11_TWFE/g4.png)



### 3B) Versi√≥n con `Y = id + t + efecto_heterog√©neo` {-}


* A√±adimos **nivel por unidad** y **tendencia temporal** a `Y`, adem√°s de heterogeneidad en el efecto (`2` y `4`).
* Refuerza la idea: **Œ≤ÃÇ TWFE** no necesariamente es el ATT promedio.


```stata
*-----------------------------------------------
clear
* Par√°metros flexibles
local units = 3
local start = 1980
local end   = 1989

local time = `end' - `start' + 1
local obsv = `units' * `time'
set obs `obsv'

* Crear variables de panel y tiempo
gen id = .
gen t  = .

forvalues i = 1/`units' {
    forvalues j = 0/`=`time'-1' {
        local obsnum = (`i' - 1)*`time' + `j' + 1
        replace id = `i' in `obsnum'
        replace t  = `start' + `j' in `obsnum'
    }
}

sort id t
xtset id t

label variable id "Unidad (panel)"
label variable t  "A√±o"

* Tratamiento para id >= 2 desde t >= 1985
gen D = 0
replace D = 1 if id >= 2 & t >= 1985
label variable D "Tratamiento desde 1985 para id >= 2"

* Generar outcome con efectos heterog√©neos
cap drop Y
gen Y = 0
replace Y = id + t + cond(D == 1, 0, 0) if id == 1
replace Y = id + t + cond(D == 1, 2, 0) if id == 2
replace Y = id + t + cond(D == 1, 4, 0) if id == 3
label variable Y "Variable dependiente (Y)"

* ----------------------------------
* Gr√°fico adaptado para a√±os reales
* ----------------------------------
twoway ///
	(connected Y t if id == 1, msymbol(circle)) ///
	(connected Y t if id == 2, msymbol(triangle)) ///
	(connected Y t if id == 3, msymbol(square)) ///
	, ///
	xline(1985, lpattern(dash)) ///
	xlabel(`start'(1)`end') ///
	legend(order(1 "id=1 (Control)" 2 "id=2 (Tratado - efecto 2)" 3 "id=3 (Tratado - efecto 4)")) ///
	title("Evoluci√≥n de Y con tratamiento heterog√©neo") ///
	xtitle("A√±o") ///
	ytitle("Y")


* -------------------------------
* Estimaci√≥n
* -------------------------------
xtreg Y D t, fe

* Comparaci√≥n con especificaciones alternativas
reg Y D                       // sin efectos fijos
reg Y D i.t                   // solo efectos fijos de tiempo
reg Y D i.id                  // solo efectos fijos de unidad
reg Y D i.t i.id              // ambos (especificaci√≥n correcta)
```

![Grafico](dofile/11_TWFE/g5.png)



## M√°s unidades, **distinto tiempo de tratamiento** (staggered) y **distinto efecto** {-}

* **id=2** se trata desde **1985**; **id=3** desde **1988** (escalonado).
* Los **tama√±os de efecto** difieren (2 vs 4).
* Estimamos varias especificaciones y usamos **Bacon decomposition** para ver **qu√© comparaciones** y **con qu√© peso** componen el Œ≤ÃÇ TWFE.
* Finalmente, estimamos pares 2√ó2 (id 1‚Äì2 e id 1‚Äì3) para ver los **componentes** del promedio.


```stata
* --------------------------------------------------
* 4. M√°s unidades, distinto tiempo de tratamiento y distinto efecto
* --------------------------------------------------

clear
* Par√°metros flexibles
local unidades = 3
local inicio = 1980
local fin    = 1989

local tiempo = `fin' - `inicio' + 1
local obs = `unidades' * `tiempo'
set obs `obs'

* Crear variables id y t con a√±os reales
gen id = .
gen t  = .

forvalues i = 1/`unidades' {
    forvalues j = 0/`=`tiempo'-1' {
        local obsnum = (`i' - 1)*`tiempo' + `j' + 1
        replace id = `i' in `obsnum'
        replace t  = `inicio' + `j' in `obsnum'
    }
}

sort id t
xtset id t

* Tratamiento escalonado: id 2 desde 1985, id 3 desde 1988
gen D = 0
replace D = 1 if id == 2 & t >= 1985
replace D = 1 if id == 3 & t >= 1988
label variable D "Tratamiento escalonado"

* Efectos distintos por grupo y tiempo
gen Y = 0
replace Y = D * 2 if id == 2 & t >= 1985
replace Y = D * 4 if id == 3 & t >= 1988
label variable Y "Variable dependiente"

* ----------------------------------
* Gr√°fico adaptado para a√±os reales
* ----------------------------------
twoway ///
  (connected Y t if id == 1, msymbol(circle)) ///
  (connected Y t if id == 2, msymbol(triangle)) ///
  (connected Y t if id == 3, msymbol(square)) ///
  , ///
  xline(1985 1988, lpattern(dash)) ///
  xlabel(`inicio'(1)`fin') ///
  legend(order(1 "id=1 (Control)" 2 "id=2 (Tratado desde 1985)" 3 "id=3 (Tratado desde 1988)")) ///
  title("Tratamiento con distintos tiempos y efectos") ///
  xtitle("A√±o") ///
  ytitle("Y")

```

![Grafico](dofile/11_TWFE/g6.png)

```stata
* ----------------------------------
* Estimaciones
* ----------------------------------
reg Y D
reg Y D i.t
reg Y D i.id
reg Y D i.t i.id

xtreg Y D i.t, fe
reghdfe Y D, absorb(id t)

```

* Descomposici√≥n de Bacon

```stata
ssc install bacondecomp, replace
bacondecomp Y D, ddetail

*LEER: Goodman-Bacon, A. (2021). Difference-in-differences with variation in treatment timing. Journal of Econometrics.

xtreg Y D i.t if (id==1 | id==2), fe robust
xtreg Y D i.t if (id==1 | id==3), fe robust	
```

# Descomposici√≥n de Bacon y ‚Äúefecto real‚Äù en DiD con adopci√≥n escalonada {-}

## ¬øQu√© es la descomposici√≥n de Bacon y por qu√© importa? {-}

Cuando el tratamiento se **adopta en momentos distintos** (staggered DiD), el coeficiente de un modelo **TWFE** (efectos fijos de unidad y tiempo) **no** es un simple DiD cl√°sico.  
Goodman-Bacon muestra que ese coeficiente es un **promedio ponderado de muchos DiD 2√ó2** construidos a partir de las comparaciones disponibles en tus datos.

En concreto, TWFE se puede escribir (a nivel intuitivo) como:

\[
\widehat\beta^{\text{TWFE}} \;=\; \sum_{k} w_k \,\widehat\beta^{(2\times2)}_k,
\]

donde cada \( \widehat\beta^{(2\times2)}_k \) es un DiD ‚Äúpeque√±o‚Äù entre dos grupos y dos periodos relevantes, y \( w_k \) es su **peso** (depende de tama√±os muestrales y de cu√°nta variaci√≥n en tratamiento aporta esa comparaci√≥n).


## Las tres familias de comparaciones 2√ó2 {-}

1. **Tratados vs. nunca tratados (T vs. U)**  
   - Comparas una cohorte **tratada** con una **nunca tratada** (usando pre vs. post del tratado).

2. **Tratados temprano vs. tratados tarde (Te vs. Cl)** ‚Äî *antes* de que los tard√≠os reciban el tratamiento  
   - Los **tard√≠os** (a√∫n no tratados) act√∫an como **control provisional** para los **tempranos**.

3. **Tratados tarde vs. tratados temprano (Tl vs. Ce)** ‚Äî *despu√©s* de que los tempranos ya est√°n tratados  
   - Los **tempranos** (ya tratados) sirven como ‚Äúcontrol‚Äù **no v√°lido** para los **tard√≠os** porque ya tienen efecto del tratamiento.

> **Clave:** En (2) y (3) est√°s comparando **tratados con tratados** en momentos distintos.  
> Si el **efecto var√≠a por cohorte** (entre unidades) o **en el tiempo desde la adopci√≥n** (din√°mico), esas comparaciones **no** miden el efecto causal que normalmente te interesa.


## ¬øCu√°l es ‚Äúel efecto real‚Äù que queremos reportar? {-}

En DiD moderno, el objetivo suele ser el **promedio de efectos entre las observaciones tratadas** en los periodos post, ponderando por su tama√±o:

\[
\textbf{ATT}_{\text{overall}}
\;=\;
\frac{\displaystyle\sum_{g,t:\,D=1} N_{g,t}\cdot \text{ATT}(g,t)}
     {\displaystyle\sum_{g,t:\,D=1} N_{g,t}},
\]

donde:
- \( g \) es la **cohorte** (grupo que adopta en un mismo momento),
- \( t \) es el **periodo**,
- \( \text{ATT}(g,t) \) es el efecto en la cohorte-tiempo,
- \( N_{g,t} \) es el n√∫mero de observaciones tratadas en esa celda.

A esto lo llamamos aqu√≠ el **‚Äúpromedio del tratamiento‚Äù** (o **ATT overall**).  
**TWFE** coincide con este promedio **solo si** el efecto **no var√≠a** ni por cohorte ni en el tiempo (homogeneidad).



## ¬øPor qu√© TWFE puede fallar con heterogeneidad? {-}

- **Heterogeneidad entre cohortes**: el tama√±o del efecto **difiere por unidad/grupo** (p. ej., id=2 tiene +2; id=3 tiene +4).  
- **Heterogeneidad din√°mica**: el efecto **cambia con el tiempo desde la adopci√≥n** (p. ej., crece cada periodo post).

En ambos casos, TWFE **mezcla** comparaciones de tipo **Te vs Cl** y **Tl vs Ce**, que **no** capturan el \(\text{ATT}(g,t)\) ‚Äúpuro‚Äù porque los ‚Äúcontroles‚Äù ya tienen (o tendr√°n) efecto en parte de la ventana.  
El promedio ponderado resultante puede **alejarse** del **ATT overall** que quieres reportar.


## Mini-ejemplos para fijar ideas {-}

### Caso 3 (tu ejemplo con tres unidades, mismo inicio y efecto por cohorte)

- Cohortes tratadas desde 1985:  
  - id=2 con efecto **+2** (constante post)  
  - id=3 con efecto **+4** (constante post)  
- Ambos tienen **el mismo n√∫mero de periodos post** (1985‚Äì1989: 5 cada uno).

**ATT overall (promedio del tratamiento)**  
Promedio entre todas las **observaciones tratadas post**:
\[
\frac{5\cdot 2 \;+\; 5\cdot 4}{5+5} \;=\; \frac{10+20}{10} \;=\; \mathbf{3}.
\]

> Aqu√≠ el promedio ‚Äúintuitivo‚Äù **s√≠** es 3.  
> TWFE puede aproximarlo cuando solo hay heterogeneidad entre cohortes pero no din√°mica y las ventanas son sim√©tricas. Aun as√≠, **Bacon** te dir√° qu√© pesos est√°n usando tus comparaciones.

---

###  Caso con **adopci√≥n escalonada** y **efectos din√°micos** {-}

- id=2 adopta en 1985 y su efecto **crece** con \(t-\text{timing}\).  
- id=3 adopta en 1988 y su efecto tambi√©n **crece** con \(t-\text{timing}\).

**ATT overall correcto**:  
haz el promedio de \(\text{ATT}(g,t)\) solo sobre **celdas tratadas** \((g,t)\), ponderado por \(N_{g,t}\).

**TWFE**:  
promedia **tambi√©n** comparaciones **tratado vs tratado** (tempranos vs tard√≠os y viceversa) ‚áí si los efectos crecen, esas comparaciones **miden diferencias de efectos**, no el efecto verdadero, y el promedio puede **sesgarse** (incluso con **pesos negativos** en ciertas descomposiciones).

---

## C√≥mo leer la salida (intuici√≥n) {-}

- **`T vs U`**: comparaciones ‚Äúlimpias‚Äù (tratados vs nunca tratados).  
- **`Te vs Cl`** y **`Tl vs Ce`**: comparaciones **entre tratados** en distintos momentos.  
- Si los pesos se concentran en estas dos √∫ltimas y sospechas **heterogeneidad**, **no conf√≠es** en TWFE como estimador del ATT overall.


## Buenas pr√°cticas (en una lista corta) {-}

- **Define tu par√°metro objetivo**: normalmente, **ATT ** (promedio sobre celdas tratadas).  
- **Estima \(\text{ATT}(g,t)\)** con m√©todos modernos (p. ej., Callaway-Sant‚ÄôAnna, Sun-Abraham, did-imputation, did2s).  
- **Promedia correctamente**: construye el **ATT ** ponderando por \(N_{g,t}\) solo sobre celdas tratadas.  
- **Usa Bacon como diagn√≥stico**: revisa qu√© comparaciones y pesos aporta TWFE; si domina ‚Äútratado vs tratado‚Äù y hay heterogeneidad, reporta el estimador moderno.

---


- **Qu√© quieres**: el **promedio del tratamiento** entre las observaciones tratadas (ATT overall).  
- **Qu√© hace TWFE**: un **promedio ponderado** de m√∫ltiples DiD 2√ó2, incluyendo **tratado vs tratado**.  
- **Cu√°ndo coincide**: solo con **efectos homog√©neos** (sin variaci√≥n por cohorte ni en el tiempo).  
- **Qu√© hacer**: estima \(\text{ATT}(g,t)\) y promedia **sobre tratadas**; usa Bacon para **auditar** a TWFE.




# ¬øC√≥mo interpretar la salida de `bacondecomp`?


```

Computing decomposition across 3 timing groups
including a never-treated group
-------------------------------

```
       Y | Coefficient  Std. err.      z    P>|z|     [95% conf. interval]
```

\-------------+----------------------------------------------------------------
D |   2.709677   .3030118     8.94   0.000     2.115785     3.30357
-------------------------------------------------------------------

Bacon Decomposition

+---------------------------------------------------+
\|                      |         Beta   TotalWeight |
\|----------------------+----------------------------|
\|         Early\_v\_Late |            2   .2419354906 |
\|         Late\_v\_Early |            4   .0967741935 |
\|       Never\_v\_timing |  2.780487813   .6612903158 |
+---------------------------------------------------+

```

---

## 1) ¬øQu√© significa cada fila?

- **Early_v_Late (Œ≤=2, peso=0.2419)**  
  Compara **tratados tempranos** vs **tratados tard√≠os** **en los per√≠odos en que los tard√≠os a√∫n no est√°n tratados**.  
  ‚Üí Identifica el efecto de la cohorte **temprana** (‚âà 2 en tu simulaci√≥n).

- **Late_v_Early (Œ≤=4, peso=0.0968)**  
  Compara **tratados tard√≠os** vs **tratados tempranos** **cuando los tempranos ya est√°n tratados**.  
  ‚Üí Usa **tratados** como ‚Äúcontrol‚Äù (no ideal si hay heterogeneidad). En tu caso rinde ‚âà **4** (efecto de la cohorte tard√≠a).

- **Never_v_timing (Œ≤‚âà2.7805, peso=0.6613)**  
  Compara **cohortes tratadas** (temprana y tard√≠a) vs **nunca tratados**.  
  ‚Üí Es un promedio (con pesos internos) de las comparaciones ‚Äútratados vs nunca tratados‚Äù a trav√©s de los distintos timings; por eso el Œ≤ cae **entre 2 y 4** y est√° m√°s cerca de 2 porque la cohorte temprana aporta m√°s periodos post.

> **Idea clave**: El coeficiente **TWFE** final es la **media ponderada** de estos DiD 2√ó2.

---

## 2) ¬øCuadra el promedio ponderado con el Œ≤ de TWFE?

S√≠. Los **pesos** suman 1:
- 0.2419354906 + 0.0967741935 + 0.6612903158 = **1.0000** (‚âà)

Promedio ponderado:
- Aporte Early_v_Late: 2 √ó 0.2419354906 = **0.483871**
- Aporte Late_v_Early: 4 √ó 0.0967741935 = **0.387097**
- Aporte Never_v_timing: 2.780487813 √ó 0.6612903158 = **1.838710**

**Suma**: 0.483871 + 0.387097 + 1.838710 = **2.709677**  
‚Üí Coincide con el **Œ≤ÃÇ de TWFE = 2.709677**.

---

## 3) ¬øPor qu√© este Œ≤ÃÇ puede **no** ser ‚Äúel efecto real promedio‚Äù?

Lo que normalmente quieres reportar es el **ATT overall**: el **promedio del efecto entre las observaciones tratadas** (cohorte-tiempo) ponderado por su tama√±o:

\[
\text{ATT}_{\text{overall}}
=
\frac{\sum_{g,t: D=1} N_{g,t}\cdot \text{ATT}(g,t)}
     {\sum_{g,t: D=1} N_{g,t}}.
\]

- En **adopci√≥n escalonada** (tempranos con m√°s a√±os post que tard√≠os) y/o con **efectos que difieren por cohorte** o en el **tiempo desde el tratamiento**, **TWFE** mezcla **tres tipos de comparaciones** (incluyendo **tratado vs tratado**), y su promedio ponderado **puede alejarse** del **ATT overall**.

**Ejemplo mental (ilustrativo):**  
Si la cohorte temprana vale **2** (m√°s a√±os post) y la tard√≠a **4** (menos a√±os post), el **promedio correcto entre celdas tratadas** puede ser algo como  
\[
\frac{5\cdot 2 + 2\cdot 4}{5+2} = \frac{18}{7} \approx 2.571,
\]
mientras que **TWFE** te dio **2.7097** porque **incluye** las comparaciones **Early_v_Late** y **Late_v_Early** con pesos 24% y 9.7%.

---

## 4) ¬øC√≥mo usar esta descomposici√≥n en la pr√°ctica?

- Si **Never_v_timing** concentra **casi todo el peso** y los efectos son **homog√©neos**, **TWFE** suele estar cerca del **ATT overall**.  
- Si hay **peso relevante** en **Early_v_Late** o **Late_v_Early** **y** sospechas **heterogeneidad** (por cohorte o din√°mica), **no** conf√≠es en TWFE para el efecto promedio.

**Recomendaci√≥n**: Estima \(\text{ATT}(g,t)\) con m√©todos modernos (p. ej., **csdid**, **eventstudyinteract**, **did_imputation**, **did2s**) y luego construye el **ATT overall** promediando **solo sobre celdas tratadas** con pesos \(N_{g,t}\).

---

## 5) Resumen en una l√≠nea

**Tu tabla dice**: el Œ≤ÃÇ de TWFE (=**2.7097**) es un **promedio ponderado** de tres DiD 2√ó2; la mayor parte (66.1%) viene de **tratados vs nunca tratados** (‚âà2.78), y el resto de **tratados vs tratados** (2 y 4).  
**Conclusi√≥n**: Para reportar ‚Äúel efecto real promedio‚Äù, usa el **ATT overall** (promedio sobre observaciones tratadas), no el Œ≤ÃÇ de TWFE cuando hay heterogeneidad o adopci√≥n escalonada.
```






---

## 5) Simulaci√≥n grande (30 unidades √ó 60 periodos) con **timings y efectos crecientes**

### Explicaci√≥n did√°ctica

* Asignamos a cada unidad una **cohorte** (0‚Äì5), un **timing de adopci√≥n** aleatorio, y un **tama√±o de efecto** aleatorio.
* El outcome `Y` crece con el tiempo y **acumula** efecto post-tratamiento: `effect * (t - timing)`.
* Graficamos las trayectorias y estimamos **TWFE** + **Bacon**.

### C√≥digo (copiar/pegar)

```stata
*********************************************************

*

clear
local units = 30
local start = 1
local end   = 60

local time = `end' - `start' + 1
local obsv = `units' * `time'
set obs `obsv'

egen id	   = seq(), b(`time')  
egen t 	   = seq(), f(`start') t(`end') 	

sort  id t
xtset id t

lab var id "Panel variable"
lab var t  "Time  variable"
set seed 13082021


cap drop Y
cap drop D
cap drop cohort
cap drop effect
cap drop timing

gen Y 	   = 0		// outcome variable	
gen D 	   = 0		// intervention variable
gen cohort = .  	// total treatment variables
gen effect = .		// treatment effect size
gen timing = .		// when the treatment happens for each cohort
levelsof id, local(lvls)
foreach x of local lvls {
	local chrt = runiformint(0,5)	
	replace cohort = `chrt' if id==`x'
}

levelsof cohort , local(lvls)  //  let all cohorts be treated for now
foreach x of local lvls {
	
	// (a) effect
	
	local eff = runiformint(2,10)
		replace effect = `eff' if cohort==`x'
		
	// (b) timing	
	
	local timing = runiformint(`start' + 5,`end' - 5)	
	replace timing = `timing' if cohort==`x'
		replace D = 1 if cohort==`x' & t>= `timing' 
}

replace Y = id + t + cond(D==1, effect * (t - timing), 0)


levelsof cohort
local items = `r(r)'

local lines
levelsof id

forval x = 1/`r(r)' {
	
	qui summ cohort if id==`x'
	local color = `r(mean)' + 1
	colorpalette tableau, nograph
		
	local lines `lines' (line Y t if id==`x', lc("`r(p`color')'") lw(vthin))	||
}

twoway ///
	`lines', legend(off)
	
	
	xtreg Y i.t D, fe
	reghdfe Y D, absorb(id t)  


bacondecomp Y D, ddetail
```

> üîç **Claves**: Este es el entorno ‚Äúrealista‚Äù donde TWFE m√°s sufre: **heterogeneidad + escalonamiento** + **din√°micas** ‚Üí pesos complicados (a veces negativos).

---

## 6) ‚ÄúSoluciones‚Äù: estimadores modernos y gr√°fico comparativo de estudios de evento

### Explicaci√≥n did√°ctica

* Simulamos nuevamente con **first\_treat** y **rel\_time** para construir **leads** (`F_#`) y **lags** (`L_#`).
* Definimos cohortes de **nunca tratados** y variables de **cohorte/gvar** para los m√©todos que lo requieren.
* **Instalamos** paquetes (hazlo una sola vez; luego puedes comentar estas l√≠neas).
* Estimamos:

  * **TWFE** (con `reghdfe`),
  * **csdid**,
  * **did\_imputation**,
  * **did\_multiplegt\_dyn**,
  * **eventstudyinteract**,
  * **did2s**,
  * **stackedev**;
    y graficamos todos juntos con `event_plot`.

> ‚ö†Ô∏è **Detalle t√©cnico**: en `reghdfe Y L_* F_*, absorb(id t) cluster(i)`, tu c√≥digo agrupa por `i`. Si tu panel es `id`, lo m√°s habitual es `cluster(id)`. **Mantengo tu comando exactamente** (como pediste), pero sugiero revisar el cluster seg√∫n tu dise√±o.

### C√≥digo (copiar/pegar)

```stata
**********************************************************************************************
*Soluciones

clear

local units = 30
local start = 1
local end 	= 60

local time = `end' - `start' + 1
local obsv = `units' * `time'
set obs `obsv'

egen id	   = seq(), b(`time')  
egen t 	   = seq(), f(`start') t(`end') 	

sort  id t
xtset id t


set seed 20211222

gen Y 	   		= 0		// outcome variable	
gen D 	   		= 0		// intervention variable
gen cohort      = .  	// treatment cohort
gen effect      = .		// treatment effect size
gen first_treat = .		// when the treatment happens for each cohort
gen rel_time	= .     // time - first_treat

levelsof id, local(lvls)
foreach x of local lvls {
	local chrt = runiformint(0,5)	
	replace cohort = `chrt' if id==`x'
}


levelsof cohort , local(lvls) 
foreach x of local lvls {
	
	local eff = runiformint(2,10)
		replace effect = `eff' if cohort==`x'
			
	local timing = runiformint(`start',`end' + 20)	// 
	replace first_treat = `timing' if cohort==`x'
	replace first_treat = . if first_treat > `end'
		replace D = 1 if cohort==`x' & t>= `timing' 
}

replace rel_time = t - first_treat
replace Y = id + t + cond(D==1, effect * rel_time, 0) + rnormal()



// generate leads and lags (used in some commands)

summ rel_time
local relmin = abs(r(min))
local relmax = abs(r(max))

	// leads
	cap drop F_*
	forval x = 2/`relmin' {  // drop the first lead
		gen F_`x' = rel_time == -`x'
	}

	
	//lags
	cap drop L_*
	forval x = 0/`relmax' {
		gen L_`x' = rel_time ==  `x'
	}
	
	
// generate the control_cohort variables  (used in some commands)

gen never_treat = first_treat==.

sum first_treat
gen last_cohort = first_treat==r(max) // dummy for the latest- or never-treated cohort


// generate the gvar variabls (used in some commands)
gen gvar = first_treat
recode gvar (. = 0)
*************************************

*Los colegas creativos
// supporting packages
ssc install schemepack, replace
ssc install avar, replace 
ssc install reghdfe, replace
ssc install event_plot, replace
ssc install palettes, replace
ssc install colrspace, replace

// DiD packages
ssc install drdid, replace
ssc install csdid, replace
ssc install did_imputation, replace
ssc install eventstudyinteract, replace
ssc install did_multiplegt, replace
ssc install stackedev, replace
ssc install did2s, replace


************
*** TWFE ***
************

reghdfe Y L_* F_*, absorb(id t) cluster(i)

estimates store twfe 

*************
*** csdid ***
*************

csdid Y, ivar(id) time(t) gvar(gvar) notyet

estat event, window(-10 10) estore(csdd) 

***********************
*** did_imputation  ***
***********************

did_imputation Y i t first_treat, horizons(0/10) pretrend(10) minn(0) 

estimates store didimp	
	
***********************
*** did_multiplegt  ***
***********************

did_multiplegt_dyn Y id t D, effects(10) placebo(10) cluster(id)

matrix didmgt_b = e(estimates) 
matrix didmgt_v = e(variances)

*****************************
***  eventstudyinteract   ***
*****************************

eventstudyinteract Y L_* F_*, vce(cluster id) absorb(id t) cohort(first_treat) control_cohort(never_treat)	

matrix evtstint_b = e(b_iw) 
matrix evtstint_v = e(V_iw)

***************		
*** did2s   ***
***************

did2s Y, first_stage(id t) second_stage(F_* L_*) treatment(D) cluster(id)

matrix did2s_b = e(b)
matrix did2s_v = e(V)

******************
*** stackedev  ***
******************

	
stackedev Y F_* L_* ref, cohort(first_treat) time(t) never_treat(never_treat) unit_fe(id) clust_unit(id)
	
matrix stackedev_b = e(b)
matrix stackedev_v = e(V)



colorpalette tableau, nograph	

event_plot    twfe	csdd    didimp  dcdh_b#dcdh_v   sa_b#sa_v   stackedev_b#stackedev_v did2s_b#did2s_v , 	///
	stub_lag( L_#   Tp#     tau#    Effect_#        L_#         L_#                     L_# 			) 		///
	stub_lead(F_# 	Tm#     pre#    Placebo_#       F_#         F_#                     F_# 			)		///
		together perturb(-0.30(0.10)0.30) trimlead(20) trimlag(20) noautolegend 									///
		plottype(scatter) ciplottype(rspike)  																	    ///
			lag_opt1(msymbol(+)   msize(1.2) mlwidth(0.3) color(black)) 	lag_ci_opt1(color(black)     lw(0.15)) 	///
			lag_opt2(msymbol(lgx) msize(1.2) mlwidth(0.3) color("`r(p1)'")) lag_ci_opt2(color("`r(p1)'") lw(0.15)) 	///
			lag_opt3(msymbol(Dh)  msize(1.2) mlwidth(0.3) color("`r(p2)'")) lag_ci_opt3(color("`r(p2)'") lw(0.15)) 	///
			lag_opt4(msymbol(Th)  msize(1.2) mlwidth(0.3) color("`r(p3)'")) lag_ci_opt4(color("`r(p3)'") lw(0.15)) 	///
			lag_opt5(msymbol(Sh)  msize(1.2) mlwidth(0.3) color("`r(p4)'")) lag_ci_opt5(color("`r(p4)'") lw(0.15)) 	///
			lag_opt6(msymbol(Oh)  msize(1.2) mlwidth(0.3) color("`r(p5)'")) lag_ci_opt6(color("`r(p5)'") lw(0.15)) 	///	 
			lag_opt7(msymbol(V)   msize(1.2) mlwidth(0.3) color("`r(p6)'")) lag_ci_opt7(color("`r(p6)'") lw(0.15)) 	///		
					graph_opt(												///
								title("DiD event study plot") 						///
								xtitle("") 									///
								ytitle("Average effect") xlabel(-20(2)20)	///
								legend(order(1 "TWFE" 3 "csdid (CS 2020)" 5 "did_imputation (BJS 2021)" 7 "did_multiplegt (CD 2020)"  9 "eventstudyinteract (SA 2020)" 11 "stackedev (CDLZ 2019)" 13 "did2s (G 2021)") pos(6) rows(3) region(style(none))) 	///
								xline(-0.5, lc(gs8) lp(dash)) ///
								yline(   0, lc(gs8) lp(dash)) ///
							 ) 
```

---

## 7) Puntos de aprendizaje (resumen)

* **TWFE** funciona bien en **2√ó2** simples, pero con **heterogeneidad** y **timing escalonado** puede:

  * Promediar comparaciones no deseadas,
  * Asignar **pesos negativos**,
  * Usar como ‚Äúcontroles‚Äù unidades ya tratadas.
* La **descomposici√≥n de Bacon** ayuda a entender **qui√©n compara con qui√©n** y **con qu√© peso**.
* Estimadores modernos (**csdid, eventstudyinteract, did\_imputation, did2s, did\_multiplegt, stackedev**) estiman **ATT(g,t)** y permiten **event studies** consistentes, evitando sesgos t√≠picos de TWFE en estos contextos.

---

## 8) Notas pr√°cticas de ejecuci√≥n

* **Instalaci√≥n**: Ejecuta una vez las l√≠neas `ssc install ‚Ä¶, replace`.
* **Clustering**: Revisa la variable correcta seg√∫n tu panel (en tu bloque TWFE final usas `cluster(i)`; si la unidad es `id`, suele ser `cluster(id)`).
* **`xtdidreg`**: Tu comando est√° como `xtdidreg`. En Stata 17/18 el oficial es `xtdidregress`. Si tu Stata no reconoce `xtdidreg`, usa `xtdidregress` con la sintaxis correspondiente.
* **Semillas**: Mantengo tus `set seed` donde aplican para replicabilidad.

