[["index.html", "Cortes Transversales Curso Avanzado de Microeconometr√≠a Aplicada Programa Informaci√≥n general Requisitos Evaluaci√≥n Bibliograf√≠a Inclusi√≥n Integridad Acad√©mica Programa del Curso", " Cortes Transversales Curso Avanzado de Microeconometr√≠a Aplicada Ana Mar√≠a D√≠az 2025-09-04 Programa Este curso pretende que el estudiante obtenga un conocimiento b√°sico de los m√©todos econom√©tricos de corte transversal. El estudiante aprender√° las principales t√©cnicas y metodolog√≠as econom√©tricas para realizar inferencia causal, √∫tiles para evaluar programas y pol√≠ticas p√∫blicas o analizar problemas econ√≥micos complejos. Tambi√©n se busca familiarizar a los estudiantes con herramientas computacionales. Se utilizar√° el paquete estad√≠stico Stata, y se realizar√° un proyecto de investigaci√≥n empleando al menos dos t√©cnicas aprendidas en el curso. Informaci√≥n general Docente: Ana Mar√≠a D√≠az Correo: a.diaze@javeriana.edu.co Oficina: S√©ptimo Piso Edificio 20 Atenci√≥n: Lunes 9‚Äì11am (con cita previa o por Teams) P√°gina web: adiazescobar.com D√≠as de clase: Martes y Jueves Horario: 7‚Äì9 am Lugar: Por definir Monitor√≠a: Por definir Requisitos Econometr√≠a Avanzada Evaluaci√≥n Componente Porcentaje Parcial 1 25% Parcial 2 25% Examen Final 25% Talleres de Clase 10% Trabajo Final 15% Trabajo Final: - Primera entrega: 10% (Presentaci√≥n de la idea) - Segunda entrega: 20% (Introducci√≥n + Descriptiva + Metodolog√≠a) - Documento final: 30% - Sustentaci√≥n: 40% Bibliograf√≠a Libros Obligatorios Cunningham, Scott (2020). Causal Inference: The Mixtape. Enlace Bernal, R. y Pe√±a, X. (2011). Gu√≠a Pr√°ctica para la Evaluaci√≥n de Impacto. Universidad de los Andes. Libros Recomendados Wooldridge (2002). Econometric Analysis of Cross Section and Panel Data. MIT Press. Angrist &amp; Pischke (2009). Mostly Harmless Econometrics. Princeton. Cameron &amp; Trivedi (2009). Microeconometrics Using Stata. Baker (2000). Evaluating the Impact of Development Projects on Poverty. World Bank. Heckman et al.¬†(2000). The Economics and Econometrics of Active Labor Market Programs. Inclusi√≥n Este curso da la bienvenida a personas de todas las edades, g√©neros, orientaciones, etnias, creencias y capacidades. Se espera un ambiente respetuoso, acogedor e inclusivo. Integridad Acad√©mica No se permite el uso de inteligencia artificial, internet o ayudas externas en evaluaciones. El incumplimiento ser√° sancionado conforme al reglamento de la Universidad. Programa del Curso A continuaci√≥n se presenta el programa semanal del curso, organizado por m√≥dulo. (#tab:programa_tabla)Programa del curso de microeconometr√≠a aplicada Semana M√≥dulo Temas Lecturas 1 1: Introducci√≥n a la Inferencia Causal ‚Ä¢ Inferencia causal ‚Ä¢ Contrafactual ‚Ä¢ Par√°metros de impacto Bernal y Pe√±a (2011), Cap. 2-3 Heckman (2008) Angrist y Pischke 2 1: Introducci√≥n a la Inferencia Causal ‚Ä¢ Sesgo de selecci√≥n Angrist &amp; Krueger (2000) 3 2: M√©todos Experimentales ‚Ä¢ Aleatorizaci√≥n ‚Ä¢ Contrafactual ‚Ä¢ Sesgo de selecci√≥n Bernal y Pe√±a (2011), Cap. 4 Duflo et al.¬†(2008) Heckman et al.¬†(1997) 4 2: M√©todos Experimentales ‚Ä¢ Impacto con aleatorizaci√≥n ‚Ä¢ Poder estad√≠stico ‚Ä¢ Problemas de aleatorizaci√≥n Duflo et al.¬†(2008) 5 3: M√©todos Cuasi-Experimentales ‚Ä¢ Regresi√≥n lineal ‚Ä¢ Supuestos de independencia condicional ‚Ä¢ Variable dependiente binaria Angrist y Pischke (2009), Cap. 3 Cameron &amp; Trivedi (2005), Cap. 14 Heckman (1990) 6-7 4: Diferencias en Diferencias y Panel ‚Ä¢ DID simple y de panel ‚Ä¢ Efectos fijos ‚Ä¢ Heterogeneidad en DID Gertler et al.¬†(2010), Cap. 6 Bertrand et al.¬†(2004) 8 4: Diferencias en Diferencias y Panel ‚Ä¢ Efectos fijos y aleatorios ‚Ä¢ Ventajas y desventajas del panel Bernal y Pe√±a (2011), Cap. 5 Angrist y Pischke (2009) 9 5: Propensity Score Matching ‚Ä¢ Estimaci√≥n del PS ‚Ä¢ Balanceo ‚Ä¢ Soporte com√∫n Bernal y Pe√±a (2011), Cap. 6 Caliendo &amp; Kopeining (2008) 10 5: Propensity Score Matching ‚Ä¢ Algoritmos de emparejamiento ‚Ä¢ Errores est√°ndar ‚Ä¢ Falsificaci√≥n Bernal y Pe√±a (2011), Cap. 6 Caliendo &amp; Kopeining (2008) 11 6: Variables Instrumentales ‚Ä¢ Definici√≥n de IV ‚Ä¢ LATE ‚Ä¢ Estimaci√≥n con variables continuas Angrist y Pischke (2009), Cap. 4 Gertler et al.¬†(2010), Cap. 7 Bernal y Pe√±a (2011), Cap. 7 12 6: Variables Instrumentales ‚Ä¢ IV con variables discretas ‚Ä¢ PSM con IV ‚Ä¢ Problemas del IV Khandker et al.¬†(2010), Cap. 6-7 13 7: Regresi√≥n Discontinua ‚Ä¢ RDD lineal ‚Ä¢ RDD no param√©trica ‚Ä¢ Sharp y Fuzzy RDD Gertler et al.¬†(2010), Cap. 5 Bernal y Pe√±a (2011), Cap. 8 14 8: Varios ‚Ä¢ Funci√≥n de control ‚Ä¢ Machine Learning Bernal y Pe√±a (2011), Cap. 9-10 bookdown::serve_book() "],["an√°lisis-de-secciones-transversales.html", "Capitulo 1 An√°lisis de Secciones Transversales Motivaci√≥n para el an√°lisis causal Motivaci√≥n para el an√°lisis causal - ¬øPor qu√© es importante? Microeconometr√≠a y pol√≠tica p√∫blica Microeconometr√≠a y teor√≠a econ√≥mica Formulando una buena pregunta causal El experimento ideal M√°s all√° del dise√±o: relevancia y aporte cient√≠fico üß∞ Checklist para una buena pregunta de investigaci√≥n causal Conceptos Importantes Ceteris Paribus Establecer Causalidad Soluci√≥n 1: Buscar una persona similar Efecto Promedio del Tratamiento (ATE) 1.1 Soluci√≥n 2: Diferencia de Medias= Efecto Causal + Sesgo de Selecci√≥n Soluci√≥n 2: Diferencia de Medias = Efecto Causal + Sesgo de Selecci√≥n Sesgo de Selecci√≥n Soluci√≥n 3: Comparaciones Antes-Despu√©s = Efecto Causal + Efecto de Maduraci√≥n Comparaciones Prohibidas ¬øY Entonces? ¬øC√≥mo podemos estimar efectos causales?", " Capitulo 1 An√°lisis de Secciones Transversales Motivaci√≥n para el an√°lisis causal En su breve y sugerente cuento Del rigor en la ciencia, Jorge Luis Borges relata la historia de un imperio en el que los cart√≥grafos llevaron su arte a un grado de perfecci√≥n tal, que terminaron por construir un mapa a escala 1:1, tan extenso y detallado como el mismo territorio que pretend√≠a representar. Con el tiempo, ese mapa fue olvidado, y sus ruinas todav√≠a se confunden con las del imperio. En aquel Imperio, el Arte de la Cartograf√≠a logr√≥ tal Perfecci√≥n que el mapa de una sola Provincia ocupaba toda una Ciudad, y el mapa del Imperio, toda una Provincia. Con el tiempo, estos Mapas Desmesurados no satisficieron y los Colegios de Cart√≥grafos levantaron un Mapa del Imperio, que ten√≠a el tama√±o del Imperio y coincid√≠a puntualmente con √©l. Menos Adictas al Estudio de la Cartograf√≠a, las Generaciones Siguientes entendieron que ese dilatado Mapa era In√∫til y no sin Impiedad lo entregaron a las Inclemencias del Sol y los Inviernos. En los desiertos del Oeste perduran despedazadas Ruinas del Mapa, habitadas por Animales y por Mendigos; en todo el Pa√≠s no hay otra reliquia de las Disciplinas Geogr√°ficas. (Su√°rez Miranda, Viajes de Varones Prudentes, Libro Cuarto, Cap. XLV, L√©rida, 1658.) FIN Sabemos que no podemos capturar la complejidad del mundo en un solo modelo, pero aspiramos a representarlo con la suficiente precisi√≥n como para entenderlo, intervenirlo y mejorarlo. En este sentido, la econometr√≠a aplicada moderna se centra en la identificaci√≥n de relaciones causales. Estas relaciones son fundamentales para comprender c√≥mo funciona el mundo social, y para guiar decisiones informadas en el dise√±o de pol√≠ticas p√∫blicas. Como explican Angrist y Pischke en su libro Mostly Harmless Econometrics: En primer lugar, creemos que la investigaci√≥n emp√≠rica es m√°s valiosa cuando utiliza datos para responder preguntas causales espec√≠ficas, como si se tratara de un ensayo cl√≠nico aleatorizado. Esta perspectiva moldea nuestro enfoque hacia la mayor√≠a de las preguntas de investigaci√≥n. En ausencia de un experimento real, buscamos comparaciones bien controladas y/o cuasiexperimentos naturales. Por supuesto, algunos dise√±os de investigaci√≥n cuasiexperimentales son m√°s convincentes que otros, pero .purple[los m√©todos econom√©tricos utilizados en estos estudios suelen ser bastante simples]. Mostly Harmless Econometrics, p.¬†xii Motivaci√≥n para el an√°lisis causal - ¬øPor qu√© es importante? ¬øC√≥mo lo entendemos? Sin duda, la identficaci√≥n de relaciones causales es fundamental para entender c√≥mo funcionan las cosas. Enteder la consecuencia de una acci√≥n es crucial para entender el mundo que nos rodea. Aqu√≠ es donde la teor√≠a econ√≥mica juega un papel central: nos proporciona un marco para interpretar esas relaciones causales, al tiempo que orienta nuestra atenci√≥n hacia posibles mecanismos. Hacer econometr√≠a sin una teor√≠a econ√≥mica s√≥lida, sin una teor√≠a del cambio ni un esfuerzo por establecer mecanismos, es simplemente machacar datos. ¬øC√≥mo lo intervenimos? Las relaciones causales nos permiten hacer predicciones sobre el impacto de intervenciones y pol√≠ticas. Por ejemplo, si sabemos que aumentar la educaci√≥n de los ni√±os mejora sus ingresos futuros, podemos dise√±ar pol√≠ticas educativas que maximicen ese efecto. Sin esta informaci√≥n, el dise√±o de pol√≠ticas se convierte en un ejercicio de ensayo y error, muchas veces costoso e ineficaz. ¬øC√≥mo mejoramos? El an√°lisis causal nos permite decir con cierta confianza qu√© cosas funcionan y bajo qu√© condiciones. Esto hace posible ajustar intervenciones para maximizar su impacto positivo. Por ejemplo, si sabemos que las transferencias monetarias condicionadas a la asistencia escolar aumentan la matr√≠cula, podemos adaptar ese dise√±o a otros contextos y poblaciones. Por esta raz√≥n, ha ganado fuerza el enfoque de pol√≠ticas basadas en evidencia, que busca reemplazar la intuici√≥n, la tradici√≥n o la ideolog√≠a con an√°lisis rigurosos del mundo real. La microeconometr√≠a aplicada, con su atenci√≥n al detalle y su vocaci√≥n por la causalidad, es una herramienta clave en esa transici√≥n. Microeconometr√≠a y pol√≠tica p√∫blica La microeconometr√≠a aplicada es una herramienta fundamental para informar y mejorar la formulaci√≥n de pol√≠ticas p√∫blicas. Sus aportes se pueden clasificar en dos tipos: Efectos directos Asignaci√≥n eficiente de recursos: permite identificar qu√© intervenciones generan mayor impacto por peso invertido. Mejora de la calidad, eficiencia y efectividad de programas e instituciones. Focalizaci√≥n en resultados, m√°s all√° de insumos o procesos. Identificaci√≥n de efectos no previstos, tanto positivos como negativos. Fortalecimiento de la rendici√≥n de cuentas, mediante evaluaciones transparentes. Efectos indirectos Alimentar el debate p√∫blico con evidencia rigurosa que permita contrastar discursos, creencias y enfoques ideol√≥gicos. Microeconometr√≠a y teor√≠a econ√≥mica Adem√°s de su valor instrumental, la microeconometr√≠a contribuye activamente al desarrollo y evaluaci√≥n de la teor√≠a econ√≥mica. Entre sus aportes est√°n: Generar mejor y m√°s informaci√≥n emp√≠rica, √∫til para contrastar modelos. Reducir el ruido, eliminando hip√≥tesis o mecanismos irrelevantes. Guiar el dise√±o de nuevas pol√≠ticas y experimentos, a partir de evidencia acumulada. Promover discusiones m√°s transparentes sobre los supuestos, facilitando la cr√≠tica constructiva. Estimular la retroalimentaci√≥n entre teor√≠a, datos y pol√≠tica. Ejemplo exitoso: Progresa (Oportunidades, M√©xico, 1990) Uno de los programas m√°s influyentes y mejor evaluados en Am√©rica Latina es Progresa, posteriormente conocido como Oportunidades y luego Prospera. Lanzado en M√©xico en 1997, su dise√±o se bas√≥ en evidencia emp√≠rica y principios de incentivos econ√≥micos. 1.0.0.1 üéØ Objetivo Reducir la pobreza y mejorar el capital humano de los hogares m√°s vulnerables, especialmente en √°reas rurales. Para eso se brid√≥ a los hogares pobres -un ingreso monetario de corto plazo -incentivos para invertir en capital humano, especialmente en la educaci√≥n y salud infantil. -Mecanismo_ Las transferencias estaban condicionadas a la asistencia escolar de los ni√±os y a visitas regulares a centros de salud. Resultados iniciales (2001) Las evaluaciones experimentales y cuasiexperimentales del programa mostraron efectos significativos: Shultz (2004): aumento promedio de 0.7 a√±os de escolaridad. Gertler (2001): reducci√≥n del 23% en incidencia de enfermedades. El programa mostr√≥ una focalizaci√≥n efectiva, beneficiando principalmente a los hogares m√°s pobres. Formulando una buena pregunta causal M√°s all√° de definir la estrategia emp√≠rica, una investigaci√≥n de calidad comienza por formular preguntas bien planteadas. En el enfoque de Angrist y Pischke, el punto de partida consiste en identificar claramente cu√°l es la relaci√≥n causal de inter√©s. Esta pregunta gu√≠a no solo el an√°lisis, sino tambi√©n la forma en que interpretamos los resultados y dise√±amos la estrategia de identificaci√≥n. Si no es posible formular de forma precisa y concisa qu√© efecto queremos estimar, es probable que a√∫n no tengamos un verdadero proyecto de investigaci√≥n. Esto no implica que las descripciones sean in√∫tiles: al contrario, los ejercicios descriptivos pueden ser valiosos e incluso necesarios. Pero en la econometr√≠a aplicada moderna, la causalidad ocupa un lugar central. Estimar relaciones causales permite poner a prueba directamente teor√≠as sobre c√≥mo funciona el mundo. Adem√°s, nos da acceso a contrafactuales, es decir, a estimaciones de qu√© habr√≠a pasado en ausencia de la intervenci√≥n o del tratamiento. Para ilustrarlo, pensemos en preguntas cl√°sicas de la literatura: ¬øC√≥mo afecta un a√±o adicional de educaci√≥n al salario? ¬øQu√© impacto tienen las instituciones democr√°ticas sobre el desarrollo econ√≥mico? ¬øLos hogares pobres se benefician de la limpieza del medio ambiente? ¬øLas leyes de control de armas reducen efectivamente la violencia? Todas estas preguntas comparten una estructura causal: comparan una situaci√≥n observable con un contrafactual no observado. Y todas ellas podr√≠an, en principio, ser abordadas mediante un dise√±o experimental o cuasiexperimental adecuado. El experimento ideal Una herramienta √∫til para clarificar la l√≥gica causal de una investigaci√≥n es imaginar el experimento ideal: aquel que asignar√≠a aleatoriamente la causa de inter√©s ‚Äîeducaci√≥n, democracia, limpieza ambiental, leyes de armas‚Äî y luego comparar√≠a los resultados. Aunque muchas veces este experimento es hipot√©tico o inviable, su formulaci√≥n nos obliga a pensar con precisi√≥n: ¬øqu√© grupo recibir√≠a el tratamiento?, ¬øqu√© factores deber√≠amos mantener constantes?, ¬øc√≥mo medir√≠amos el efecto? Cuando no es posible siquiera imaginar c√≥mo ser√≠a un experimento ideal, puede que estemos enfrentando lo que Angrist y Pischke denominan preguntas fundamentalmente sin respuesta. Por ejemplo, preguntas como ‚Äú¬øQu√© efecto tiene el g√©nero sobre las trayectorias laborales futuras?‚Äù o ‚Äú¬øQu√© rol juega la raza en los ingresos?‚Äù plantean desaf√≠os √©ticos, conceptuales y metodol√≥gicos dif√≠ciles de sortear. En cambio, hay preguntas que, aunque complejas, s√≠ permiten imaginar un experimento. Por ejemplo, si quisi√©ramos estimar el efecto de comenzar la escuela a una edad m√°s avanzada, podr√≠amos imaginar un dise√±o en el que a algunos ni√±os se les asigna aleatoriamente empezar el primer grado a los seis a√±os, y a otros, a los siete. Luego, comparar√≠amos sus puntajes en pruebas estandarizadas al final del segundo grado. Aun as√≠, este dise√±o enfrenta un problema: los ni√±os que comienzan m√°s tarde son tambi√©n m√°s grandes, y la madurez puede explicar parte de las diferencias. Es decir, la edad y la duraci√≥n de la escolarizaci√≥n quedar√≠an entrelazadas. Incluso con un experimento ideal, algunos efectos son dif√≠ciles de aislar completamente. M√°s all√° del dise√±o: relevancia y aporte cient√≠fico Adem√°s de identificar con claridad la relaci√≥n causal y el experimento ideal, una buena investigaci√≥n causal tambi√©n debe justificar su importancia. Algunas preguntas clave que los investigadores deben hacerse al definir su objeto de estudio son: ¬øpor qu√© esta pregunta es relevante o interesante?, ¬øpor qu√© la literatura existente no ha resuelto a√∫n esta cuesti√≥n?, y ¬øc√≥mo contribuye mi trabajo a avanzar esa frontera? Estas preguntas ayudan a ubicar el proyecto dentro de un marco m√°s amplio, que no solo busca estimar efectos, sino tambi√©n producir conocimiento √∫til, replicable y te√≥ricamente informado. üß∞ Checklist para una buena pregunta de investigaci√≥n causal ## Warning: &#39;xfun::attr()&#39; is deprecated. ## Use &#39;xfun::attr2()&#39; instead. ## See help(&quot;Deprecated&quot;) Table 1.1: Checklist para formular una buena pregunta de investigaci√≥n causal Pregunta Descripci√≥n ¬øCu√°l es la relaci√≥n causal de inter√©s? Define con claridad qu√© variable act√∫a como causa y cu√°l como efecto. ¬øPuedes describir el experimento ideal? Imagina c√≥mo se asignar√≠a aleatoriamente el tratamiento y c√≥mo medir√≠as el impacto. ¬øPor qu√© esta pregunta es importante o interesante? Justifica la relevancia emp√≠rica, social o pol√≠tica del tema. ¬øQu√© aporta respecto a la literatura existente? Identifica vac√≠os o limitaciones en estudios previos que tu trabajo busca superar. ¬øQu√© mecanismos o teor√≠a motivan la hip√≥tesis causal? Aseg√∫rate de que haya una narrativa te√≥rica detr√°s de la relaci√≥n que estudias. Conceptos Importantes El Contrafactual ¬øCu√°l habr√≠a sido el resultado para los participantes si no hubieran participado? Este concepto es fundamental en la inferencia causal: cada persona tiene un resultado observado y un resultado potencial no observado. Este √∫ltimo es el contrafactual, es decir, lo que habr√≠a ocurrido si la persona hubiera estado en la otra condici√≥n (tratada o no tratada). Visualizando el Contrafactual Participante (Tratado) \\(Y_1 \\Rightarrow\\) Resultado observado No Participante (Control) \\(Y_0 \\Rightarrow\\) Resultado del contrafactual La Banda Sonora Resultados Potenciales Cada individuo tiene dos posibles resultados: \\(Y_i(D=0)\\): resultado si no recibe el tratamiento \\(Y_i(D=1)\\): resultado si recibe el tratamiento Pero solo uno de ellos es observable. Por ejemplo, Carolina tiene una pierna rota. Tratamiento: \\(D=0\\) No ir al hospital, \\(D=1\\) Ir al hospital \\(Y_i(0)\\): si no va al hospital, su pierna no se recupera \\(Y_i(1)\\): si va al hospital, su pierna no se recupera Ahora veamos a Camila quien tambi√©n tiene una pierna rota. \\(Y_i(0)\\): si no va al hospital, su pierna no se recupera \\(Y_i(1)\\): si va al hospital, su pierna se recupera Por √∫ltimpo est√° M√≥nica quien tambi√©n tiene una pierna rota. \\(Y_i(0)\\): si no va al hospital, su pierna se recupera \\(Y_i(1)\\): si va al hospital, su pierna no se recupera Pregunta: ¬øa cual de las tres le conviene ir al hospital? Problema Fundamental de la Inferencia Causal Nunca podemos observar los dos resultados potenciales para un mismo individuo. Esto genera un problema de datos faltantes: no sabemos cu√°l habr√≠a sido el resultado bajo la condici√≥n alternativa. Solo observamos uno de los dos resultados potenciales. Formalmente: \\[ Y_i = \\begin{cases} Y_i(0) &amp; \\text{si } D_i = 0 \\\\ Y_i(1) &amp; \\text{si } D_i = 1 \\\\ \\end{cases} \\] donde \\(D_i\\) indica si el individuo fue tratado (\\(D_i=1\\)) o no (\\(D_i=0\\)). Establecer Causalidad (Deseo de Clonaci√≥n) En el mundo ideal, podr√≠amos clonar personas para observar ambos resultados. Como esto no es posible, buscamos estimaciones mediante grupos de comparaci√≥n. Tratado \\(Y_1 \\Rightarrow\\) Resultado observado Clon en Control \\(Y_0 \\Rightarrow\\) Resultado contrafactual Ver en YouTube 1.0.1 üé• Video recomendado: Mastering Metrics Ceteris Paribus Todos los dem√°s factores permanecen constantes. Este principio es la piedra angular del an√°lisis causal. Para estimar el efecto de una intervenci√≥n o tratamiento, debemos aislar su impacto de todas las dem√°s influencias posibles. Idealmente, quisi√©ramos comparar un mundo donde algo ocurre con uno donde no ocurre, manteniendo todo lo dem√°s constante. Establecer Causalidad Nunca observamos ambos estados (tratado y no tratado) para el mismo individuo. ¬øQu√© soluciones existen? Buscar una persona similar en todas las caracter√≠sticas relevantes. Comparar promedios entre grupos tratados y no tratados (‚ö†Ô∏è puede haber sesgo de selecci√≥n). Comparar antes y despu√©s en los mismos individuos (‚ö†Ô∏è puede haber sesgo de maduraci√≥n). Soluci√≥n 1: Buscar una persona similar 1.0.2 Ceteris Paribus: ¬øPerfecto? Tratada \\(Y_1 \\Rightarrow\\) resultado observado Control \\(Y_0 \\Rightarrow\\) resultado del contrafactual Efecto Promedio del Tratamiento (ATE) El Average Treatment Effect (ATE) se define como: \\[ ATE = E[\\tau] = E[Y_i(D=1) - Y_i(D=0)] \\] Pero si no podemos observar los dos resultados potenciales para un mismo individuo, tampoco podemos calcular directamente este promedio. 1.1 Soluci√≥n 2: Diferencia de Medias= Efecto Causal + Sesgo de Selecci√≥n .pull-left[ Tratados ] .pull-right[ Controles ] Soluci√≥n 2: Diferencia de Medias = Efecto Causal + Sesgo de Selecci√≥n Una alternativa com√∫n para estimar efectos causales es comparar los promedios de los grupos tratados y no tratados. Sin embargo, esta estrategia suele estar contaminada por sesgo de selecci√≥n: los grupos pueden diferir de manera sistem√°tica en variables que tambi√©n afectan el resultado. .pull-left[ Tratados ] .pull-right[ Controles ] Sesgo de Selecci√≥n El sesgo de selecci√≥n ocurre cuando las personas que reciben un tratamiento son inherentemente diferentes de aquellas que no lo reciben. Estas diferencias pueden estar asociadas con los resultados que estamos tratando de medir, incluso si no hubieran recibido el tratamiento. Incluso con muestras grandes, este problema persiste. Por ejemplo, las personas suelen decidir participar en un programa cuando creen que obtendr√°n beneficios, lo que significa que sus resultados podr√≠an haber sido distintos desde el principio. En otras palabras, \\(E[Y_i(D=1) - Y_i(D=0)]\\) puede ser mayor para quienes se auto-seleccionan. Soluci√≥n 3: Comparaciones Antes-Despu√©s = Efecto Causal + Efecto de Maduraci√≥n Otra estrategia simple consiste en comparar los resultados antes y despu√©s del tratamiento para los mismos individuos. Esta comparaci√≥n, sin embargo, asume impl√≠citamente que no hay tendencia temporal en la variable de inter√©s. Es decir, que cualquier cambio entre el ‚Äúantes‚Äù y el ‚Äúdespu√©s‚Äù se debe exclusivamente al tratamiento. Esta suposici√≥n es d√©bil, especialmente en contextos donde hay aprendizaje, adaptaci√≥n o efectos acumulativos en el tiempo. Comparaciones Prohibidas En el an√°lisis causal riguroso, debemos ser esc√©pticos de dos comparaciones muy comunes: Tratados vs.¬†Controles sin aleatorizaci√≥n Pre-tratamiento vs.¬†Post-tratamiento sin grupo de comparaci√≥n Ambas requieren supuestos extremadamente fuertes ‚Äîen muchos casos imposibles de verificar o cumplir en la pr√°ctica‚Äî para identificar un efecto causal v√°lido. ¬øY Entonces? Dada la imposibilidad de observar directamente el contrafactual y los riesgos de comparaciones inadecuadas, ¬øc√≥mo podemos avanzar en el an√°lisis causal? .pull-left[ .fuente[Fuente: @banrepcultural] ] ¬øC√≥mo podemos estimar efectos causales? Hoy en d√≠a contamos con un conjunto robusto de herramientas para abordar esta pregunta. Estas t√©cnicas buscan crear contrafactuales plausibles, ya sea mediante dise√±o experimental o estrategias cuasi-experimentales. Entre las principales estrategias se encuentran: Experimentos aleatorizados: donde los participantes son asignados aleatoriamente al tratamiento y al control. M√©todos cuasi-experimentales, como: Diferencias en diferencias (DiD) Emparejamiento (Matching) Variables instrumentales (IV) Regresi√≥n discontinua (RD) Funci√≥n de control Controles sint√©ticos Causal Machine Learning Cada uno de estos m√©todos tiene fortalezas y limitaciones, y ser√° explorado en detalle a lo largo del libro. "],["stata-para-principiantes.html", "Capitulo 2 Stata para Principiantes Macros en Stata Loops en Stata Programas definidos por el usuario Almacenamiento de resultados con postfile y loops Resumen y buenas pr√°cticas ¬øY si quiero hacerlo en R o Python? 1. Asignar valores y mostrar texto 2. Operaciones b√°sicas 3. Loops b√°sicos 4. Crear funciones/programas 5. Guardar resultados dentro de un loop DESCARGA LOS DOCUMENTOS", " Capitulo 2 Stata para Principiantes Puedes consultar el Stata Cheat Sheet completo aqu√≠: https://geocenter.github.io/StataTraining/pdf/AllCheatSheets.pdf Macros en Stata Las macros en Stata son herramientas para almacenar texto que luego puede reutilizarse en comandos posteriores. No son variables, no almacenan datos num√©ricos como tal, sino texto que puede ser evaluado o invocado m√°s adelante. Se usan con frecuencia para simplificar c√≥digo, automatizar tareas repetitivas, o construir loops. Stata tiene dos tipos principales de macros: local: v√°lidas solo dentro del entorno donde se definieron (por ejemplo, dentro de un programa o loop). global: v√°lidas en todo el entorno de trabajo mientras dure la sesi√≥n (desaconsejadas para la mayor√≠a de tareas por riesgo de sobreescritura accidental). Macro local: definici√≥n y expansi√≥n local uno 1 display `uno&#39; Esto imprimir√° 1 en la consola. La macro uno se expande y sustituye por su contenido (1) antes de ejecutar el comando. Evaluar expresiones dentro de macros Si queremos que Stata evalue una expresi√≥n, usamos el signo igual = luego del nombre del macro. local suma = 2 + 2 display `suma&#39; Stata calcula 2 + 2 y guarda el resultado 4 como texto dentro de suma. Al hacer display, se imprime el n√∫mero 4. Macro con texto local saludo &quot;¬°Hola, mundo!&quot; display &quot;`saludo&#39;&quot; Esto mostrar√°: ¬°Hola, mundo! Ojo: cuando una macro contiene texto, siempre encierra su invocaci√≥n entre comillas para evitar errores de interpretaci√≥n. Macro global: uso y precauci√≥n global pi 3.1416 display $pi Al usar global, la invocaci√≥n se hace con signo d√≥lar ($). El contenido se mantiene accesible en toda la sesi√≥n. ‚ö†Ô∏è Se recomienda evitar nombres obvios en global ya que puede generar conflictos si se reutilizan nombres con comandos establecidos. Scalar vs.¬†Macro Un scalar almacena valores num√©ricos (reales), no texto. Se usa para c√°lculos matem√°ticos, estad√≠sticas o comparaciones num√©ricas. scalar x = 2 + 3 display x Esto imprime 5. scalar area = 3.1416 * (2^2) display area Resultado: 12.5664 Diferencia clave: macro: almacena texto (puede ser n√∫mero, pero como cadena). scalar: almacena un n√∫mero real que puede usarse en operaciones matem√°ticas. Buenas pr√°cticas Usa local por defecto. Usa nombres descriptivos para evitar confusi√≥n. Cierra comillas cuando el contenido tiene espacios o texto. Borra scalars con scalar drop nombre si ya no los necesitas. üß© Ejercicio recomendado Crea una macro con tu nombre y otra con tu a√±o de nacimiento. Luego muestra una frase concatenando ambas: local nombre &quot;Ana&quot; local nacimiento 1980 display &quot;Hola, mi nombre es `nombre&#39; y nac√≠ en `nacimiento&#39;&quot; Las macros son esenciales para automatizar an√°lisis en Stata. √ösalas para loops, programaci√≥n y construcci√≥n flexible de comandos. Loops en Stata Los loops en Stata permiten automatizar tareas repetitivas, iterando sobre listas de elementos o rangos num√©ricos. Son muy √∫tiles cuando necesitas aplicar un mismo comando a varias variables, realizar simulaciones o crear m√∫ltiples gr√°ficos/tablas de forma eficiente. Loop con foreach foreach itera sobre una lista de elementos, que pueden ser: nombres de variables palabras clave n√∫meros, si se combinan con of numlist a) Iterar sobre variables espec√≠ficas foreach var in mpg price displacement { regress `var&#39; weight } b) Iterar sobre nombres arbitrarios foreach color in rojo azul verde { display &quot;El color es `color&#39;&quot; } c) Iterar sobre variables en la base usando of varlist sysuse auto, clear foreach v of varlist price weight length { summarize `v&#39; } d) Iterar sobre subconjuntos: condici√≥n y resultado foreach s of varlist price weight { quietly summarize `s&#39; if foreign == 1 display &quot;Promedio de `s&#39; para foreign = 1: &quot; r(mean) } Loop con forvalues forvalues itera sobre una secuencia num√©rica definida por un rango o paso. a) Secuencia simple forvalues i = 1/5 { display &quot;Iteraci√≥n `i&#39;&quot; } b) Incrementos diferentes forvalues j = 10(2)20 { display &quot;`j&#39;&quot; } c) Anidar loops con forvalues forvalues i = 1/3 { forvalues j = 1/3 { display &quot;Fila: `i&#39;, Columna: `j&#39;&quot; } } Loop con while while permite ejecutar c√≥digo mientras una condici√≥n sea verdadera. Es √∫til para estructuras de control m√°s manuales o condicionales m√°s complejas. local i = 1 while `i&#39; &lt;= 5 { display &quot;`i&#39;&quot; local ++i } üß† Ejercicios recomendados Usa foreach para crear un gr√°fico histogram para cada una de las siguientes variables: mpg, price, y weight. Usa forvalues para crear 10 variables llamadas x1, x2, ‚Ä¶, x10 con valores aleatorios entre 0 y 100. Crea un loop anidado que calcule y muestre el producto de cada par (i, j) para i en 1 a 3 y j en 1 a 4. Usa while para contar hacia atr√°s desde 10 hasta 1. En un loop, calcula la media de cada variable num√©rica del conjunto de datos, pero solo si su desviaci√≥n est√°ndar es mayor que 5. Programas definidos por el usuario En Stata puedes definir tus propios programas usando el comando program define. Esto es especialmente √∫til para empaquetar comandos que usas con frecuencia o para crear rutinas m√°s limpias dentro de proyectos complejos. Estructura b√°sica program define saludo display &quot;Hola, FELIZ d√≠a&quot; end saludo Este programa se llama saludo y simplemente imprime un mensaje. Para ejecutarlo, basta con escribir su nombre. Programas con argumentos Puedes pasar informaci√≥n a un programa con args o con syntax. a) Con args capture program drop cuadrado program define cuadrado args x display &quot;El cuadrado de `x&#39; es: &quot; = `x&#39;^2 end cuadrado 4 Esto imprimir√°: El cuadrado de 4 es: 16 b) Con syntax (m√°s power) capture program drop promedio program define promedio syntax varlist(min=1 max=1) summarize `varlist&#39; end promedio mpg syntax verifica que se cumpla una estructura: aqu√≠, exactamente una variable. Tu programa original mejorado: mysum capture program drop mysum program define mysum syntax varlist(min=1 max=1) quietly summarize `varlist&#39; display &quot;Variable: `varlist&#39;&quot; display &quot;Promedio: &quot; %6.2f r(mean) display &quot;Desviaci√≥n est√°ndar: &quot; %6.2f r(sd) end mysum weight Notas importantes Siempre usar capture program drop nombre antes de definir uno nuevo. Usa syntax cuando quieras controlar argumentos y prevenir errores. Dentro del programa, puedes acceder a estad√≠sticas almacenadas con r(), e(), etc. Usa quietly para ejecutar comandos sin mostrar su salida completa. üîß Ejercicios recomendados Crea un programa llamado saluda que reciba un nombre y diga ‚ÄúHola, [nombre]‚Äù. Crea un programa promedio_si que calcule el promedio de una variable solo para observaciones que cumplen una condici√≥n (por ejemplo, foreign == 1). Usa args para pasar la variable. Define un programa llamado comparar que reciba dos variables y calcule la diferencia de medias entre ambas (no un ttest, solo mean(var1) - mean(var2)). Intenta crear un programa con syntax que valide que el usuario haya pasado exactamente una variable, y que esta sea num√©rica. Si no, que d√© un mensaje de error. Almacenamiento de resultados con postfile y loops Cuando queremos guardar resultados generados dentro de un loop para analizarlos despu√©s (por ejemplo, coeficientes, medias, errores est√°ndar), Stata nos ofrece una herramienta poderosa: postfile. ¬øQu√© hace postfile? Permite crear una tabla temporal (como una mini base de datos) en la que puedes ir guardando los resultados de cada iteraci√≥n del loop. Al final, puedes abrirla como si fuera cualquier base. Paso a paso: guardar medias con summarize Supongamos que queremos guardar la media y la desviaci√≥n est√°ndar de varias variables num√©ricas de forma automatizada. sysuse auto, clear tempname resultados tempfile archivo postfile `resultados&#39; str15 variable media sd using `archivo&#39; foreach var in price weight length { quietly summarize `var&#39; post `resultados&#39; (&quot;`var&#39;&quot;) (r(mean)) (r(sd)) } postclose `resultados&#39; use `archivo&#39;, clear list ¬øQu√© hicimos aqu√≠? tempname crea un alias para el objeto de postfile. tempfile genera una ruta temporal para almacenar los resultados. postfile define las variables a guardar (aqu√≠: nombre, media y desviaci√≥n est√°ndar). Dentro del loop, usamos post para guardar cada fila. Cerramos con postclose. Cargamos el archivo resultante con use y lo exploramos. Buenas pr√°cticas Usa tempfile para evitar escribir archivos por accidente. Usa tipos de datos adecuados: str para nombres, numeric para estad√≠sticas. Siempre cierra el objeto con postclose antes de usar el archivo. üì¶ Ejercicios con postfile Modifica el ejemplo para guardar tambi√©n el n√∫mero de observaciones (r(N)). Aplica un regress en un loop sobre varias variables dependientes y guarda los coeficientes de weight en cada una. Crea una base de resultados que incluya, por cada variable, un indicador l√≥gico que diga si su media es mayor a 500. Exporta la base final a Excel usando export excel. Resumen y buenas pr√°cticas A lo largo de este cap√≠tulo exploramos los componentes fundamentales para comenzar a trabajar eficientemente en Stata. Aprendimos a: Usar macros locales y globales para automatizar tareas y hacer c√≥digo m√°s flexible. Escribir loops (foreach, forvalues, while) para aplicar comandos de forma repetida sin redundancia. Definir programas personalizados usando program define, con argumentos simples (args) o controlados (syntax). Implementar un programa divertido con frases de reguet√≥n, mostrando que tambi√©n se puede aprender con humor. Utilizar postfile para almacenar resultados generados dentro de loops y analizarlos de manera estructurada. Buenas pr√°cticas al programar en Stata ‚úÖ Usa local en lugar de global siempre que sea posible. ‚úÖ Nombra tus macros y archivos temporales de forma clara y consistente. ‚úÖ Usa capture para evitar errores si un programa ya existe. ‚úÖ Cierra siempre postfile con postclose antes de usar el archivo. ‚úÖ Usa syntax dentro de tus programas para validar entradas del usuario. ‚úÖ No olvides comentar tu c√≥digo. Facilita su mantenimiento y revisi√≥n. ‚úÖ Cuando sea posible, grafica tus resultados. Visualizar patrones es clave. ‚úÖ Prefiere loops bien documentados a copiar y pegar comandos. üß† Ejercicio de repaso Imagina que est√°s analizando una base de datos de estudiantes. Quieres: Crear un loop que recorra varias variables (como math_score, reading_score, attendance). Para cada variable: Calcular la media y desviaci√≥n est√°ndar Guardar esos valores con postfile Escribir un programa llamado informe_var que reciba una variable y muestre un mini informe con: Nombre de la variable Media Desviaci√≥n est√°ndar Mensaje personalizado si la media es mayor a un umbral dado Ejecutar informe_var dentro del loop usando syntax ¬øY si quiero hacerlo en R o Python? Aqu√≠ les dejo c√≥mo realizar tareas comunes de an√°lisis de datos en Stata, R y Python. Puede servir como gu√≠a r√°pida para quienes est√°n aprendiendo varios lenguajes a la vez o quieren migrar entre ellos. 1. Asignar valores y mostrar texto Tarea Stata R Python Asignar un n√∫mero scalar x = 5 x &lt;- 5 x = 5 Asignar texto local nombre \"Ana\" nombre &lt;- \"Ana\" nombre = \"Ana\" Mostrar texto + var display \"Holanombre‚Äô‚Äù cat(paste(\"Hola\", nombre)) print(f\"Hola {nombre}\") 2. Operaciones b√°sicas Operaci√≥n Stata R Python Suma display 2+2 2 + 2 2 + 2 Ra√≠z cuadrada display sqrt(4) sqrt(4) math.sqrt(4) Valor absoluto abs(-2) abs(-2) abs(-2) En R necesitas library() si usas sqrt. En Python, debes importar import math. 3. Loops b√°sicos Iterar sobre lista de variables Stata: foreach var in var1 var2 var3 { summarize `var&#39; } R: for (var in c(&quot;var1&quot;, &quot;var2&quot;, &quot;var3&quot;)) { summary(df[[var]]) } Python: for var in [&quot;var1&quot;, &quot;var2&quot;, &quot;var3&quot;]: print(df[var].describe()) 4. Crear funciones/programas Stata: program define cuadrado args x display &quot;Resultado: &quot; = `x&#39;^2 end cuadrado 4 R: cuadrado &lt;- function(x) { return(x^2) } cuadrado(4) Python: def cuadrado(x): return x**2 cuadrado(4) 5. Guardar resultados dentro de un loop Stata (con postfile): tempname resultados tempfile archivo postfile `resultados&#39; str10 var media using `archivo&#39; foreach v of varlist x1 x2 x3 { quietly summarize `v&#39; post `resultados&#39; (&quot;`v&#39;&quot;) (r(mean)) } postclose `resultados&#39; use `archivo&#39;, clear R: resultados &lt;- data.frame(var = character(), media = numeric()) for (v in c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;)) { media &lt;- mean(df[[v]], na.rm = TRUE) resultados &lt;- rbind(resultados, data.frame(var = v, media = media)) } Python: resultados = [] for v in [&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;]: media = df[v].mean() resultados.append({&quot;var&quot;: v, &quot;media&quot;: media}) resultados_df = pd.DataFrame(resultados) DESCARGA LOS DOCUMENTOS Descargar Stata do file: Descargar Stata Descargar R script: Descargar R Descargar Phyton Notebook: Descargar Phyton Descarga los Datos Descargar Datos "],["definici√≥n-de-estimadores-resultados-potenciales-e-introducci√≥n-al-sesgo-de-selecci√≥n.html", "Capitulo 3 üìò Definici√≥n de estimadores, resultados potenciales e introducci√≥n al sesgo de selecci√≥n üéØ Metas de aprendizaje üìö Lecturas recomendadas üî¢ Ejercicio en clase: Resultados potenciales y sesgo de selecci√≥n", " Capitulo 3 üìò Definici√≥n de estimadores, resultados potenciales e introducci√≥n al sesgo de selecci√≥n üéØ Metas de aprendizaje Entender qu√© es un resultado potencial Diferenciar entre ATE, ATT, ATU y el estimador na√Øve Comprender la l√≥gica del sesgo de selecci√≥n y su relaci√≥n con los contrafactuales üìö Lecturas recomendadas Lectura 1: The Credibility Revolution - Angrist y Pischke (2010) Enlace al art√≠culo Lectura 2: Bernal y Pe√±a ‚Äì Cap√≠tulo 2 Lectura 3: Bernal y Pe√±a ‚Äì Cap√≠tulo 3 üîπ Resultados potenciales Para cada unidad \\(i\\), existen dos posibles resultados: \\(Y_i(D=1)\\): resultado si recibe tratamiento \\(Y_i(D=0)\\): resultado si no recibe tratamiento Pero solo observamos uno de ellos: \\[ Y_i = D_i \\cdot Y_i(D=1) + (1 - D_i) \\cdot Y_i(D=0) \\] Donde: - \\(D_i = 1\\) si la unidad fue tratada - \\(D_i = 0\\) si no fue tratada üîπ Par√°metros de inter√©s üìå Efecto Promedio del Tratamiento (ATE) \\[ ATE = \\mathbb{E}[Y_i(D=1) - Y_i(D=0)] \\] üìå Efecto Promedio del Tratamiento sobre los Tratados (ATT) \\[ ATT = \\mathbb{E}[Y_i(D=1) - Y_i(D=0) \\mid D_i = 1] \\] üìå Efecto Promedio del Tratamiento sobre los No Tratados (ATU) \\[ ATU = \\mathbb{E}[Y_i(D=1) - Y_i(D=0) \\mid D_i = 0] \\] üìå Estimador na√Øve (comparaci√≥n directa de medias) \\[ \\mathbb{E}[Y_i \\mid D_i = 1] - \\mathbb{E}[Y_i \\mid D_i = 0] \\] üîπ ¬øPor qu√© no es suficiente el estimador na√Øve? El estimador na√Øve asume impl√≠citamente que: \\[ \\mathbb{E}[Y_i(D=0) \\mid D_i = 1] = \\mathbb{E}[Y_i(D=0) \\mid D_i = 0] \\] Es decir, que los grupos tratados y no tratados son comparables en su resultado contrafactual. Este supuesto es poco realista si la asignaci√≥n al tratamiento est√° relacionada con factores que afectan el resultado, como motivaci√≥n, ingresos o necesidad. üîπ Sesgo de selecci√≥n El sesgo de selecci√≥n se define como la diferencia entre el estimador na√Øve y el verdadero ATT: \\[ \\text{Sesgo} = \\left( \\mathbb{E}[Y_i(D=1) \\mid D_i = 1] - \\mathbb{E}[Y_i(D=0) \\mid D_i = 1] \\right) - \\left( \\mathbb{E}[Y_i(D=1) \\mid D_i = 1] - \\mathbb{E}[Y_i(D=0) \\mid D_i = 0] \\right) \\] Lo que se reduce a: \\[ \\text{Sesgo} = \\mathbb{E}[Y_i(D=0) \\mid D_i = 0] - \\mathbb{E}[Y_i(D=0) \\mid D_i = 1] \\] Si los no tratados (controles) tienen peores resultados potenciales que los tratados, el estimador na√Øve sobreestima el verdadero efecto del tratamiento. {-} üî¢ Ejercicio en clase: Resultados potenciales y sesgo de selecci√≥n Supongamos que tenemos una muestra de 8 individuos. Algunos recibieron tratamiento (\\(D = 1\\)) y otros no (\\(D = 0\\)). Cada persona tiene dos resultados potenciales: \\(Y(1)\\): lo que obtendr√≠a si recibe el tratamiento \\(Y(0)\\): lo que obtendr√≠a si no lo recibe Pero solo observamos uno de esos dos valores: \\[ Y_i = D_i \\cdot Y_i(1) + (1 - D_i) \\cdot Y_i(0) \\] Datos ID \\(D_i\\) \\(Y_i(D=0)\\) \\(Y_i(D=1)\\) \\(Y_i\\) 1 1 10 12 12 2 0 4 5 4 3 1 9 10 10 4 1 10 11 11 5 0 5 6 5 6 0 3 2 3 7 1 12 11 11 8 0 5 7 5 üéØ Preguntas para discutir en grupo ¬øCu√°l es el contrafactual que NO podemos observar para cada individuo? Calcula el efecto promedio del tratamiento sobre los tratados (ATT). Calcula el estimador na√Øve: \\[ \\mathbb{E}[Y \\mid D = 1] - \\mathbb{E}[Y \\mid D = 0] \\] ¬øCu√°l es el sesgo de selecci√≥n entre ambos estimadores? Reflexiona: ¬øpor qu√© hay sesgo en este ejemplo? ¬øQu√© supuesto impl√≠cito est√° fallando? üìå Pista: Los individuos tratados tienen mejores valores de \\(Y(0)\\) (lo que habr√≠an obtenido sin tratamiento) que los no tratados. ¬øEs v√°lido entonces comparar directamente los promedios observados entre grupos? üîπ Sesgo en comparaciones antes-despu√©s (sin grupo de control) Una estrategia com√∫n es comparar el resultado promedio antes y despu√©s del tratamiento en el mismo grupo de individuos tratados: \\[ \\text{Estimador Antes-Despu√©s} = \\mathbb{E}[Y_{t=1} \\mid D = 1] - \\mathbb{E}[Y_{t=0} \\mid D = 1] \\] Este estimador es observable, pero no necesariamente causal, porque no tenemos el contrafactual de lo que habr√≠a pasado en \\(t = 1\\) sin tratamiento. ¬øQu√© observamos? En \\(t = 1\\), observamos \\(Y(d=1)\\): el resultado con tratamiento En \\(t = 0\\), observamos \\(Y(d=0)\\): el resultado sin tratamiento Para identificar el efecto del tratamiento, lo que quisi√©ramos conocer es: \\[ Y(d=0) \\text{ en } t = 1 \\] Es decir, ¬øqu√© habr√≠a pasado en el periodo \\(t=1\\) si no hubi√©ramos tratado a nadie? üí° El efecto causal real para una unidad ser√≠a: \\[ Y(d=1) - Y(d=0) \\text{ en el mismo periodo } t=1 \\] Pero en el dise√±o antes-despu√©s usamos \\(Y(d=0)\\) del periodo anterior como sustituto de ese contrafactual. Entonces, el sesgo es: \\[ \\text{Sesgo} = \\underbrace{\\mathbb{E}[Y(d=0) \\text{ en } t = 1]}_{\\text{contrafactual deseado}} - \\underbrace{\\mathbb{E}[Y(d=0) \\text{ en } t = 0]}_{\\text{valor observado como &quot;antes&quot;}} \\] Este sesgo aparece si el resultado habr√≠a cambiado con el tiempo incluso sin el tratamiento. üß™ Ejemplo ilustrativo A√±o Resultado observado Tratamiento 2019 6 0 (antes) 2020 9 1 (despu√©s) Estimador antes-despu√©s: \\[ 9 - 6 = 3 \\] Pero supongamos que, sin tratamiento, el resultado en 2020 habr√≠a sido 8 \\[ \\Rightarrow Y(d=0) \\text{ en } 2020 = 8 \\] Entonces el efecto causal verdadero es: \\[ 9 - 8 = 1 \\] Y el sesgo de selecci√≥n por tiempo es: \\[ 3 - 1 = 2 \\] El dise√±o antes-despu√©s asume que no habr√≠a cambio en el tiempo sin tratamiento. Este supuesto es muy fuerte y raramente cierto. Por eso, necesitamos un grupo de control que nos ayude a estimar \\(\\mathbb{E}[Y(d=0) \\text{ en } t=1]\\). En otras palabras, sin grupo de control no podemos saber si el cambio fue por el tratamiento o por el tiempo. Estos videos ayudan a reforzar visualmente los conceptos de resultados potenciales, contrafactuales y sesgo en el dise√±o antes-despu√©s. üõ†Ô∏è üí¨ PROMPT DE CHATGPT PARA REFLEXI√ìN PROFUNDA Est√°s escribiendo el apartado metodol√≥gico de un art√≠culo donde se implementa un programa de formaci√≥n t√©cnica para j√≥venes. Tu grupo de tratamiento incluye individuos que aplicaron y fueron aceptados. No tienes grupo de control expl√≠cito, pero tienes datos de resultados antes y despu√©s. üìå Instrucciones: Escribe a ChatGPT usando el siguiente mensaje: Act√∫a como mi tutor metodol√≥gico. No quiero que simplemente expliques los conceptos, sino que me hagas preguntas, desaf√≠es mis supuestos, y me ayudes a razonar paso a paso como si estuvi√©ramos en una asesor√≠a. üß™ Contexto: Quiero evaluar el efecto de un programa de formaci√≥n t√©cnica para j√≥venes. Tengo datos de ingreso mensual antes y despu√©s del programa, pero solo para quienes participaron. Estoy pensando en calcular: YÃÑ_despues - YÃÑ_antes para reportar el efecto del programa. Quiero que me ayudes a pensar cr√≠ticamente si esta estrategia identifica un efecto causal. Por favor: Gu√≠ame para identificar cu√°l es el verdadero contrafactual que estoy ignorando. Preg√∫ntame qu√© estoy asumiendo impl√≠citamente. Expl√≥rame en qu√© condiciones este estimador funcionar√≠a bien. Hazme reflexionar sobre qu√© sesgos podr√≠an surgir si los ingresos hubieran aumentado igual sin el programa. Ll√©vame a conectar este ejemplo con los conceptos de Y(D=1), Y(D=0), ATT, ATE y el estimador na√Øve. ‚ö†Ô∏è Importante: no me lo des todo resuelto. Quiero que me vayas preguntando cosas, como har√≠a un buen profe. Quiero pensar, no solo escuchar. Hazlo interactivo. "],["estimadores-causales-en-secciones-transversales.html", "Capitulo 4 Estimadores Causales en Secciones Transversales üìö Lecturas obligatorias üìé Descargas üìé Descargas", " Capitulo 4 Estimadores Causales en Secciones Transversales üìö Lecturas obligatorias Lectura 4 ‚Äì Cap√≠tulo 4 del libro de Scott Cunningham: üëâ Mixtape: Potential Outcomes Documento de referencia sobre RCT: üìÑ RCT.pdf üéØ Objetivo de la clase Aprenderemos a estimar y comparar distintos estimadores del efecto causal: ATE (Efecto Promedio en la Poblaci√≥n) ATT (Efecto Promedio en los Tratados) ATU (Efecto Promedio en los No Tratados) Estimador Na√Øve (diferencia observada entre grupos) Repasamos conceptos de la clase anterior: resultados potenciales, estimadores de media y regresi√≥n simple. üì• Cargar la base y generar la variable de resultado observado use &quot;04_data.dta&quot;, clear * Generamos el resultado observado seg√∫n el tratamiento recibido gen y = D*yd1 + (1-D)*yd0 label var y &quot;Salarios en millones de pesos&quot; label define D 0 &quot;Control&quot; 1 &quot;Tratados&quot; label value D D numlabel, add üìä Estad√≠sticas descriptivas por grupo tab D D | Freq. Percent Cum. ------------+----------------------------------- 0. Control | 4 50.00 50.00 1. Tratados | 4 50.00 100.00 ------------+----------------------------------- Total | 8 100.00 sum y Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- y | 8 7.625 3.700869 3 12 bysort D: sum y ------------------------------------------------------------------------------------------ -&gt; D = 0. Control Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- y | 4 4.25 .9574271 3 5 ------------------------------------------------------------------------------------------ -&gt; D = 1. Tratados Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- y | 4 11 .8164966 10 12 sum y if D == 0 Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- y | 4 4.25 .9574271 3 5 sum y if D == 1 Variable | Obs Mean Std. dev. Min Max -------------+--------------------------------------------------------- y | 4 11 .8164966 10 12 Nos permite observar las diferencias promedio entre grupos tratados y de control. üìé Diferencia de medias ttest y, by(D) Two-sample t test with equal variances ------------------------------------------------------------------------------ Group | Obs Mean Std. err. Std. dev. [95% conf. interval] ---------+-------------------------------------------------------------------- 0. Contr | 4 4.25 .4787136 .9574271 2.72652 5.77348 1. Trata | 4 11 .4082483 .8164966 9.700772 12.29923 ---------+-------------------------------------------------------------------- Combined | 8 7.625 1.308455 3.700869 4.530996 10.719 ---------+-------------------------------------------------------------------- diff | -6.75 .6291529 -8.289482 -5.210518 ------------------------------------------------------------------------------ diff = mean(0. Contr) - mean(1. Trata) t = -10.7287 H0: diff = 0 Degrees of freedom = 6 Ha: diff &lt; 0 Ha: diff != 0 Ha: diff &gt; 0 Pr(T &lt; t) = 0.0000 Pr(|T| &gt; |t|) = 0.0000 Pr(T &gt; t) = 1.0000 reg y D, robust üìé Regresio√≥n Simple Modelo: \\[ Y = \\alpha + \\tau D + \\varepsilon \\] \\(\\tau\\) representa el estimador na√Øve (diferencia de medias observada). No es causal si hay sesgo de selecci√≥n. Linear regression Number of obs = 8 F(1, 6) = 115.11 Prob &gt; F = 0.0000 R-squared = 0.9505 Root MSE = .88976 ------------------------------------------------------------------------------ | Robust y | Coefficient std. err. t P&gt;|t| [95% conf. interval] -------------+---------------------------------------------------------------- D | 6.75 .6291529 10.73 0.000 5.210518 8.289482 _cons | 4.25 .4787136 8.88 0.000 3.07863 5.42137 ------------------------------------------------------------------------------ üßÆ Estimaci√≥n de ATE, ATT y ATU gen tau = yd1 - yd0 // efecto individual display &quot;ATE: &quot; sum tau scalar ATE = r(mean) di &quot;ATE = &quot; ATE sum tau if D == 1 scalar ATT = r(mean) di &quot;ATT = &quot; ATT sum tau if D == 0 scalar ATU = r(mean) di &quot;ATU = &quot; ATU üßØ Comparaci√≥n con el estimador na√Øve sum y if D==1 scalar ybar_1 = r(mean) sum y if D==0 scalar ybar_0 = r(mean) scalar NAIVE = ybar_1 - ybar_0 di &quot;Naive = &quot; NAIVE di &quot;Sesgo de selecci√≥n = &quot; NAIVE - ATT ‚öôÔ∏è Programa para estimadores cap prog drop estimadores program define estimadores args tau y D di &quot;--- Calculando estimadores ---&quot; quietly { sum `tau&#39; scalar ATE = r(mean) sum `tau&#39; if `D&#39; == 1 scalar ATT = r(mean) sum `tau&#39; if `D&#39; == 0 scalar ATU = r(mean) sum `y&#39; if `D&#39; == 1 scalar ybar_1 = r(mean) sum `y&#39; if `D&#39; == 0 scalar ybar_0 = r(mean) scalar NAIVE = ybar_1 - ybar_0 } di &quot;ATE = &quot; ATE di &quot;ATT = &quot; ATT di &quot;ATU = &quot; ATU di &quot;Naive = &quot; NAIVE di &quot;Sesgo de Selecci√≥n = &quot; NAIVE - ATT end * Llamamos el programa: estimadores tau y D üß™ Experimento 1: ¬øQu√© pasa si aumento el tama√±o muestral? drop y tau expand 10000 * Generar nuevamente el resultado gen y = D*yd1 + (1-D)*yd0 gen tau = yd1 - yd0 estimadores tau y D üîç Moraleja: Aumentar el tama√±o no elimina el sesgo si hay selecci√≥n. üß™ Experimento 2: Asignaci√≥n aleatoria drop y D tau set seed 87634 gen D = (uniform() &gt; 0.5) gen y = D*yd1 + (1-D)*yd0 * Repetimos estimadores gen tau = yd1 - yd0 estimadores tau y D ... üéØ Con asignaci√≥n aleatoria: \\[ ATE \\approx ATT \\approx ATU \\approx Na√Øve \\] üß† Reflexiones finales El estimador na√Øve es solo v√°lido si hay asignaci√≥n aleatoria. La diferencia entre ATT y Na√Øve nos permite cuantificar el sesgo de selecci√≥n. El ATE no es igual al ATT si hay heterogeneidad en el tratamiento. El tama√±o muestral no soluciona problemas de sesgo. üìé Descargas Descargar Stata do file: Descargar Stata Descargar R script: Descargar R Descargar Phyton Notebook: Descargar Phyton Descarga los Datos: Descargar Datos üîç **Moraleja:** Aumentar el tama√±o no elimina el sesgo si hay selecci√≥n. --- *üß™ Experimento 2: Asignaci√≥n aleatoria * ```stata drop y D tau set seed 87634 gen D = (uniform() &gt; 0.5) gen y = D*yd1 + (1-D)*yd0 * Repetimos estimadores gen tau = yd1 - yd0 sum tau scalar ATE = r(mean) ... üéØ Con asignaci√≥n aleatoria: \\[ ATE \\approx ATT \\approx ATU \\approx Na√Øve \\] üß† Reflexiones finales El estimador na√Øve es solo v√°lido si hay asignaci√≥n aleatoria. La diferencia entre ATT y Na√Øve nos permite cuantificar el sesgo de selecci√≥n. El ATE no es igual al ATT si hay heterogeneidad en el tratamiento. El tama√±o muestral no soluciona problemas de sesgo. üìé Descargas Descargar Stata do file: Descargar Stata Descargar R script: Descargar R Descargar Phyton Notebook: Descargar Phyton Descarga los Datos: Descargar Datos "],["por-qu√©-la-asignaci√≥n-aleatoria-elimina-el-sesgo.html", "Capitulo 5 ¬øPor qu√© la asignaci√≥n aleatoria elimina el sesgo? ¬øQu√© hace la aleatorizaci√≥n? Densidad de la motivaci√≥n por grupo", " Capitulo 5 ¬øPor qu√© la asignaci√≥n aleatoria elimina el sesgo? üéØ Objetivo del cap√≠tulo ‚úîÔ∏è Entender qu√© se debe cumplir para que un experimento sea exitoso y reduzca el sesgo de selecci√≥n ‚úîÔ∏è Conocer las diferentes formas de realizar asignaci√≥n aleatoria ‚úîÔ∏è Traducir los resultados potenciales a una regresi√≥n lineal üìö Lecturas üìÑ Paper Alert: When Should You Adjust Standard Errors for Clustering? (NBER) üìÑ Teor√≠a: Lectura 4. Cap√≠tulo 4 Bernal y Pe√±a (PDF) Tenemos el siguiente modelo de regresi√≥n lineal: \\[ Y = \\alpha + \\tau D + \\varepsilon \\] Donde: \\(Y\\) es el resultado (por ejemplo, salario), \\(D\\) es una variable binaria de tratamiento, \\(\\varepsilon\\) incluye motivaci√≥n, que no observamos. Supongamos que la verdadera relaci√≥n es: \\[ Y = \\alpha + \\tau D + \\gamma M + u \\] Donde: \\(M\\) es motivaci√≥n (no observable), \\(u\\) es un nuevo error sin correlaci√≥n con \\(D\\), Pero no incluimos \\(M\\) en la estimaci√≥n ‚Üí queda absorbido en \\(\\varepsilon = \\gamma M + u\\) El modelo estimado es: \\[ Y = \\alpha + \\tau D + \\varepsilon \\quad \\text{con} \\quad \\varepsilon = \\gamma M + u \\] Recordemos que el estimador de m√≠nimos cuadrados ordinarios es: \\[ \\hat{\\beta} = (X&#39;X)^{-1} X&#39;Y \\] Con \\(X = [\\mathbf{1}, D]\\), tenemos: \\[ \\hat{\\beta} = \\begin{bmatrix} \\hat{\\alpha} \\\\ \\hat{\\tau} \\end{bmatrix} = \\left( \\begin{bmatrix} 1 &amp; D_1 \\\\ \\vdots &amp; \\vdots \\\\ 1 &amp; D_n \\\\ \\end{bmatrix}&#39; \\begin{bmatrix} 1 &amp; D_1 \\\\ \\vdots &amp; \\vdots \\\\ 1 &amp; D_n \\\\ \\end{bmatrix} \\right)^{-1} \\begin{bmatrix} 1 &amp; D_1 \\\\ \\vdots &amp; \\vdots \\\\ 1 &amp; D_n \\\\ \\end{bmatrix}&#39; Y \\] Queremos analizar el sesgo en \\(\\hat{\\tau}\\). Sustituyendo \\(Y = \\alpha + \\tau D + \\gamma M + u\\) Entonces: \\[ \\hat{\\tau} = \\tau + \\gamma \\cdot \\frac{\\text{Cov}(D, M)}{\\text{Var}(D)} \\] Interpretaci√≥n Si \\(\\text{Cov}(D, M) \\neq 0\\), es decir, si el tratamiento est√° correlacionado con la motivaci√≥n, el estimador de \\(\\tau\\) estar√° sesgado. El sesgo es proporcional a: El efecto de la motivaci√≥n sobre \\(Y\\): \\(\\gamma\\) La correlaci√≥n entre \\(D\\) y \\(M\\): \\(\\text{Cov}(D, M)\\) Resumen del sesgo Correlaci√≥n entre \\(D\\) y \\(M\\) Efecto de \\(M\\) sobre \\(Y\\) (\\(\\gamma\\)) ¬øHay sesgo en \\(\\hat{\\tau}\\)? Direcci√≥n esperada del sesgo Cero Cualquiera ‚ùå No ‚Äì Positiva Positiva ‚úÖ S√≠ \\(\\hat{\\tau} &gt; \\tau\\) (sesgo hacia arriba) Positiva Negativa ‚úÖ S√≠ \\(\\hat{\\tau} &lt; \\tau\\) (sesgo hacia abajo) Negativa Positiva ‚úÖ S√≠ \\(\\hat{\\tau} &lt; \\tau\\) (sesgo hacia abajo) Negativa Negativa ‚úÖ S√≠ \\(\\hat{\\tau} &gt; \\tau\\) (sesgo hacia arriba) Lectura de la tabla: Si el tratamiento est√° correlacionado positivamente con la motivaci√≥n y la motivaci√≥n aumenta el resultado, el estimador de \\(\\tau\\) estar√° sesgado hacia arriba. Si la motivaci√≥n est√° omitida y adem√°s est√° correlacionada con el tratamiento, siempre hay sesgo. Solo si la motivaci√≥n no est√° correlacionada con el tratamiento, aunque no la observemos, no hay sesgo. ¬øQu√© hace la aleatorizaci√≥n? üìå La aleatorizaci√≥n garantiza \\(\\text{Cov}(D, M) = 0\\), eliminando el sesgo de selecci√≥n sin necesidad de observar \\(M\\). Visualizaci√≥n: motivaci√≥n, selecci√≥n y aleatorizaci√≥n Densidad de la motivaci√≥n por grupo Por lo tanto ya no es necesario observar la motivaci√≥n, ya que la aleatorizaci√≥n garantiza que los grupos sean comparables. Y la estimaci√≥n de \\(\\tau\\) ser√° insesgada y consistente en la siguiente regresi√≥n: \\[ Y = \\alpha + \\tau D + u \\] Cual es el valor de \\(\\alpha\\) y \\(\\tau\\) en este caso? ¬øPor qu√© se incluyen controles en el an√°lisis de RCT? ¬øQu√© pasa si no se incluyen? ¬øCalcule los errores est√°ndar? Video 1 Video 2 Video 3 Y todos los que encuentres en Google buscando: RCT Esther Duflo üõ†Ô∏è üí¨ PROMPT DE CHATGPT PARA REFLEXI√ìN PROFUNDA Instrucciones: Copia este mensaje en ChatGPT o la IA de tu preferencia. Tu objetivo no es obtener respuestas, sino reflexionar guiado por preguntas. Hola. Act√∫a como mi tutor metodol√≥gico. No quiero que me des respuestas. Quiero que me ayudes a pensar como si estuvi√©ramos en una tutor√≠a. Estoy estudiando dise√±os experimentales. Entiendo que si el tratamiento se asigna aleatoriamente, entonces \\(\\text{Cov}(D, X) = 0\\), incluso para variables no observables. Pero sigo viendo que en muchos papers experimentales incluyen controles en la regresi√≥n. Ay√∫dame a pensar paso a paso si eso es necesario o no. Por favor, hazme preguntas como: ¬øQu√© gana o pierde la estimaci√≥n si incluyo controles? ¬øQu√© pasa si hay desequilibrios por azar? ¬øQu√© efecto tiene sobre la precisi√≥n del estimador? ¬øLos controles ayudan a mejorar algo aunque \\(\\hat{\\tau}\\) ya sea insesgado? ¬øHay casos en que incluir controles puede ser problem√°tico? ‚ö†Ô∏è No me des respuestas. Solo nuevas preguntas que me ayuden a entender mejor este punto. "],["experimentos-controlados-receta.html", "Capitulo 6 Experimentos Controlados RECETA üìö Lecturas Paso a Paso para un RCT Inferencia estad√≠stica ¬øCu√°ndo incluir controles? Efectos heterog√©neos (HET) DESCARGA LOS DOCUMENTOS", " Capitulo 6 Experimentos Controlados RECETA üéØ Metas de aprendizaje Entender c√≥mo hacer inferencia estad√≠stica con asignaci√≥n aleatoria. Discutir cu√°ndo incluir controles y qu√© ocurre con la varianza/SE al incluirlos. Traducir resultados potenciales a una regresi√≥n lineal. Implementar diagn√≥sticos de balance, efectos heterog√©neos y reporte reproducible. üìö Lecturas Paper Alert: When Should You Adjust Standard Errors for Clustering? (NBER w24003) Teor√≠a: Jakiela &amp; Ozier ‚Äî Handout Herramienta: J-PAL ‚Äî Power calculations 1) Setup Unidades: \\(N\\). Tratamiento: \\(D_i \\in \\{0,1\\}\\). Asignado de manera aleatoria. Resultados potenciales: \\(Y_i(D=1),\\, Y_i(D=0)\\). Resultado observado: \\[ Y_i \\;=\\; D_i\\,Y_i(D=1) \\;+\\; (1-D_i)\\,Y_i(D=0). \\] Tama√±os de muestra: Tratados: \\(N_1 = \\sum_i \\mathbb{1}\\{D_i=1\\}\\). Control: \\(N_0 = \\sum_i \\mathbb{1}\\{D_i=0\\}\\). 2) Supuestos Asignaci√≥n aleatoria: cada unidad \\(i\\) es asignada de manera independiente al tratamiento con probabilidad \\(p\\). \\[ D_i \\;\\perp\\; \\{Y_i(1), Y_i(0)\\}. \\] SUTVA (Stable Unit Treatment Value Assumption): no hay interferencia entre unidades ni versiones del tratamiento. En espa√±ol: no hay externalidades ni efectos de equilibrio general que cambien los resultados potenciales de otros individuos. 3) Implicaciones y par√°metros ATE (efecto promedio): \\[ \\tau \\;=\\; \\mathbb{E}\\!\\left[\\,Y(D=1)-Y(D=0)\\,\\right]. \\] Identificaci√≥n con aleatorizaci√≥n: \\[ \\mathbb{E}[\\,Y \\mid D=1\\,] - \\mathbb{E}[\\,Y \\mid D=0\\,] \\;=\\; \\tau. \\] Estimador por diferencia de medias: \\[ \\hat{\\tau} \\;=\\; \\bar{Y}_{D=1}-\\bar{Y}_{D=0}. \\] Estimador ‚Äúna√Øve‚Äù sin aleatorizaci√≥n (descomposici√≥n): \\[ \\underbrace{\\mathbb{E}[Y \\mid D=1] - \\mathbb{E}[Y \\mid D=0]}_{\\text{na√Øve}} \\;=\\; \\underbrace{\\tau}_{\\text{efecto causal}} \\;+\\; \\underbrace{\\mathbb{E}[Y(0)\\mid D=1] - \\mathbb{E}[Y(0)\\mid D=0]}_{\\text{sesgo de selecci√≥n}}. \\] Paso a Paso para un RCT PASO 1) Dise√±ar el experimento Definir la poblaci√≥n objetivo y el tratamiento. Determinar el tama√±o de muestra necesario para detectar un efecto significativo (usando power en Stata/R). Paso 2) Aleatorizar la asignaci√≥n (Stata) Abajo tienes varias formas de asignar tratamiento en Stata. Incluyo opciones con runiform() (base) y con el comando de SSC randtreat (estratificado, proporciones desiguales, clusters y manejo de misfits). Regla de oro: fija una semilla reproducible y gu√°rdala en el log/notas del proyecto. * Reproducibilidad set seed 20250813 local RNGSTATE = c(rngstate) // guardar estado; opcionalmente escr√≠belo en tu log display as text &quot;Seed guardada: `RNGSTATE&#39;&quot; Bernoulli simple (50/50) con runiform() Asigna tratamiento con probabilidad 0.5 a cada unidad. * Sup√≥n que tienes un id por fila sort id gen double u = runiform() gen byte D = (u &lt; 0.5) // 1=tratado, 0=control tab D drop u Cambio de proporci√≥n (p=0.30): gen double u = runiform() gen byte D = (u &lt; 0.30) tab D drop u Asignaci√≥n con conteo exacto de tratados (p.ej., 40% exacto) Asegura exactamente round(N*0.40) tratados. count local N = r(N) local Ntr = round(`N&#39;*0.40) // n√∫mero exacto de tratados gen double u = runiform() sort u gen byte D = (_n &lt;= `Ntr&#39;) tab D drop u Estratificada (bloques) con runiform() Mant√©n la proporci√≥n deseada dentro de cada estrato (ej., por mujer √ó programa). Con round() obtienes conteo exacto por estrato; globalmente puede variar levemente si los tama√±os de estrato son impares. egen long strata = group(mujer programa), label bys strata: gen double u = runiform() bys strata (u): gen byte D = (_n &lt;= round(_N*0.50)) // 50/50 exacto en cada estrato tab D by strata: tab D drop u Proporci√≥n distinta por estrato (p.ej., 40%): bys strata: gen double u = runiform() bys strata (u): gen byte D = (_n &lt;= round(_N*0.40)) by strata: tab D drop u Cluster (aleatoriza a nivel del cluster y la pasa a individuos) Ej.: clusters en escuela. * Una fila por cluster preserve keep escuela duplicates drop gen double u = runiform() sort u * 50% de escuelas tratadas count local C = r(N) local Ctr = round(`C&#39;*0.50) gen byte D_cluster = (_n &lt;= `Ctr&#39;) tempfile cl save `cl&#39;, replace restore * Trae la asignaci√≥n al nivel individual merge m:1 escuela using `cl&#39;, keep(match master) nogen gen byte D = D_cluster tab D Usando randtreat (SSC): multi-brazos, proporciones desiguales, estratos y misfits Instalaci√≥n ssc install randtreat, replace Binario 50/50 (sin estratos) randtreat, generate(D) multiple(2) setseed(20250813) tab D Binario 50/50 dentro de estratos (mujer √ó programa) randtreat, generate(D) multiple(2) strata(mujer programa) setseed(20250813) by mujer programa: tab D ** Proporciones desiguales (30% tratado, 70% control)** randtreat, generate(D) multiple(2) unequal(0.30 0.70) setseed(20250813) tab D ** Multi-brazo (T1/T2/C = 0.4/0.4/0.2) con estratos** randtreat, generate(arm) multiple(3) unequal(0.40 0.40 0.20) /// strata(mujer programa) setseed(20250813) tab arm by mujer programa: tab arm Manejo de misfits Cuando el tama√±o de estrato no es divisible por los brazos/proporciones, usa misfits(): misfits(strata) o misfits(wstrata): resuelve dentro de cada estrato (ponderado o no). misfits(global) o misfits(wglobal): resuelve a nivel global priorizando las proporciones totales. misfits(missing): deja misfits sin asignar para que los decidas manualmente. randtreat, generate(arm) multiple(3) unequal(0.40 0.40 0.20) /// strata(mujer programa) misfits(wstrata) setseed(20250813) Forzar n√∫mero exacto de tratados totales (binario) √ötil si necesitas exactamente N_t tratados (no solo proporci√≥n). * Por ejemplo, exactamente 50 tratados en total: randtreat, generate(D) multiple(2) ntreated(50) setseed(20250813) tab D Cluster + randtreat Ejecuta randtreat sobre los clusters √∫nicos y luego une a individuos. preserve keep escuela mujer programa duplicates drop * 2 brazos 50/50 por estratos de escuela (y opcionalmente otras): randtreat, generate(Dcl) multiple(2) strata(mujer programa) setseed(20250813) tempfile cl save `cl&#39;, replace restore merge m:1 escuela using `cl&#39;, nogen gen byte D = Dcl tab D PASO 3) Verificar el balance de covariables use &quot;data.dta&quot;, clear * Tratamiento 1=B, 0=A gen D = (grupo == &quot;B&quot;) label define Dlbl 0 &quot;Control&quot; 1 &quot;Tratado&quot; label values D Dlbl * Outcome y y controles gen y = resultado gen mujer = (genero == &quot;Mujer&quot;) gen pregrado = (programa == &quot;Pregrado&quot;) gen maestria = (programa == &quot;Maestr√≠a&quot;) global X edad mujer libros pregrado maestria Programa de diferencia de medias con t-test y opci√≥n de guardar resultados en un archivo .dta** Pruebas univariadas (t‚Äêtests): comparar medias de cada covariable \\(X\\) entre \\(D=1\\) y \\(D=0\\). Objetivo: no rechazar que las medias son iguales. Prueba conjunta (F‚Äêtest): regresi√≥n de \\(D\\) sobre \\(X\\) (LPM) y test conjunto de significancia de \\(X\\). Modelos binarios: logit/probit de \\(D\\) sobre \\(X\\); evaluar raz√≥n de verosimilitud o \\(\\chi^2\\) conjunta. Si se rechaza balance: revisar procedimiento (bloqueos/estratos, reasignaci√≥n, control por \\(X\\) pretratamiento en la estimaci√≥n). cap program drop difmedias program define difmedias, rclass version 18 syntax varlist(min=1) [, BY(varname) SAVEPOST(string asis)] if (&quot;`by&#39;&quot;==&quot;&quot;) { di as err &quot;Necesitas especificar , by(varname).&quot; exit 198 } local vars `varlist&#39; local do_post = 0 if (&quot;`savepost&#39;&quot;!=&quot;&quot;) local do_post = 1 tempname posth if `do_post&#39; { postfile `posth&#39; str32 variable /// double mean_T mean_C diff tstat pval se sd_T sd_C N_T N_C /// using &quot;`savepost&#39;&quot;, replace } di as txt &quot;Var{col 22}Mean_T{col 33}Mean_C{col 44}Diff{col 55}t{col 66}p&quot; foreach v of local vars { qui ttest `v&#39;, by(`by&#39;) local mu1 = r(mu_1) local mu2 = r(mu_2) local sd1 = r(sd_1) local sd2 = r(sd_2) local N1 = r(N_1) local N2 = r(N_2) local t = r(t) local se = r(se) local p = r(p) local mean_T = `mu2&#39; local mean_C = `mu1&#39; local diff = `mu2&#39; - `mu1&#39; di as res &quot;`v&#39;&quot; &quot;{col 22}&quot; %9.3f `mean_T&#39; &quot;{col 33}&quot; %9.3f `mean_C&#39; &quot;{col 44}&quot; %9.3f `diff&#39; &quot;{col 55}&quot; %9.3f `t&#39; &quot;{col 66}&quot; %9.3f `p&#39; if `do_post&#39; { post `posth&#39; (&quot;`v&#39;&quot;) (`mean_T&#39;) (`mean_C&#39;) (`diff&#39;) (`t&#39;) (`p&#39;) (`se&#39;) (`sd2&#39;) (`sd1&#39;) (`N2&#39;) (`N1&#39;) } } if `do_post&#39; postclose `posth&#39; end * Balance de X difmedias $X, by(D) savepost(&quot;Table_Balance_raw.dta&quot;) use &quot;Table_Balance_raw.dta&quot;, clear order variable mean_T mean_C diff tstat pval se sd_T sd_C N_T N_C export excel using &quot;Table_Balance_raw.xlsx&quot;, firstrow(variables) replace * ALTERNATIVAS cap which iebaltab if _rc ssc install ietoolkit, replace iebaltab $X, grpvar(D) control(0) rowvarlabels ftest /// savexlsx(&quot;Table_Balance.xlsx&quot;) replace format(%9.3f) eststo clear eststo: reg D $X, vce(robust) test $X eststo: logit D $X, vce(robust) eststo: probit D $X, vce(robust) esttab, se star(* 0.10 ** 0.05 *** 0.01) /// stats(N r2, fmt(%9.0g %9.3f) labels(&quot;N&quot; &quot;R2&quot;)) /// nomtitle compress PASO 4) Estimar el efecto del tratamiento \\[ Y_i \\;=\\; \\alpha \\;+\\; \\tau D_i \\;+\\; \\varepsilon_i. \\] - Bajo aleatorizaci√≥n, \\(\\hat{\\tau}_{OLS}\\) es insesgado y coincide con la diferencia de medias. Sea \\(D\\) la columna binaria (0/1) y \\(\\iota\\) el vector de unos. Entonces, en \\(Y = \\alpha \\iota + \\tau D + \\varepsilon\\), se tiene: \\[ \\hat{\\tau} \\;=\\; \\bar{Y}_1 - \\bar{Y}_0. \\] eststo clear eststo m1: reg y D, vce(robust) eststo m2: reg y D $X, vce(robust) esttab m1 m2, se star(* 0.10 ** 0.05 *** 0.01) /// stats(N r2, fmt(%9.0g %9.3f) labels(&quot;N&quot; &quot;R2&quot;)) /// b(%9.4f) compress nonote /// title(&quot;Efecto del tratamiento con y sin controles&quot;) Interpretaci√≥n seg√∫n escala de \\(Y\\) \\(Y\\) en niveles (continuo): \\(\\hat{\\tau}\\) es diferencia de unidades de \\(Y\\) entre tratados y control. \\(Y\\) en logaritmos: \\(\\hat{\\tau}\\) es una semi-elasticidad; el efecto porcentual aproximado es \\(100\\times \\hat{\\tau}\\%\\). Efecto exacto: \\(100\\times(\\exp(\\hat{\\tau})-1)\\%\\). Ejemplo: \\(\\hat{\\tau}=0.13 \\Rightarrow \\exp(0.13)-1 \\approx 0.139\\) ‚Üí 13.9%. \\(Y\\) estandarizado: media 0 y varianza 1; \\(\\hat{\\tau}\\) se interpreta en desviaciones est√°ndar. \\(Y\\) binario: \\(\\hat{\\tau}\\) es diferencia de probabilidades (puntos porcentuales). Ejemplo: \\(p_1=0.30\\), \\(p_0=0.25\\) ‚áí \\(\\hat{\\tau}=0.05 = 5\\) pp. Inferencia estad√≠stica Asignaci√≥n a nivel individual (dos muestras independientes) Varianza del estimador (cl√°sica): \\[ \\operatorname{Var}(\\hat{\\tau}) \\;\\approx\\; \\frac{S_1^2}{N_1} \\;+\\; \\frac{S_0^2}{N_0}, \\] donde \\(S_1^2\\) y \\(S_0^2\\) son las varianzas muestrales por grupo. Heterocedasticidad: usar SE robustas (HC). Asignaci√≥n por clusters: usar SE cluster al nivel de asignaci√≥n. Con pocos clusters, considerar wild cluster bootstrap. Pruebas Significancia individual: \\(H_0:\\,\\tau=0\\) (t‚Äêtest). Significancia conjunta de \\(X\\): en \\(D \\sim X\\), \\(H_0:\\,\\beta_X=0\\) (F/\\(\\chi^2\\)). Queremos no rechazar. ¬øCu√°ndo incluir controles? Identificaci√≥n: con aleatorizaci√≥n correcta, no necesitas \\(X\\) para identificar \\(\\tau\\). Precisi√≥n: incluir \\(X\\) pretratamiento que expliquen \\(Y\\) puede reducir \\(\\operatorname{Var}(\\hat{\\tau})\\) (menor varianza residual). Si \\(X\\) es irrelevante o colineal, puede aumentar la SE de \\(\\hat{\\tau}\\). Modelo con controles: \\[ Y_i \\;=\\; \\alpha + \\tau D_i + X_i&#39;\\beta + u_i. \\] Si \\(X \\perp D\\) (por dise√±o) y \\(X\\) explica \\(Y\\), esperar SE(D) m√°s peque√±as. Efectos heterog√©neos (HET) Especificaci√≥n general: \\[ Y_i \\;=\\; \\alpha \\;+\\; \\tau D_i \\;+\\; \\gamma W_i \\;+\\; \\delta\\, (D_i \\times W_i) \\;+\\; X_i&#39;\\beta \\;+\\; u_i, \\] donde \\(W\\) es el moderador (p.¬†ej., mujer, libros, cuartiles de edad). Interpretaci√≥n: \\(\\delta\\) es el cambio en el efecto de \\(D\\) al pasar de un nivel de \\(W\\) a otro. Usar margins/marginsplot para reportar efectos marginales y perfiles por subgrupo. * Por mujer (binaria) eststo clear eststo: reg y D##i.mujer, vce(robust) margins, dydx(D) margins D, at(mujer=(0 1)) * Por libros (continua) eststo: reg y D##c.libros, vce(robust) margins, dydx(D) at(libros=(0(1)8)) marginsplot, title(&quot;Efecto marginal de D seg√∫n libros&quot;) graph export &quot;margins_libros.pdf&quot;, replace * Por cuartiles de edad xtile q_edad = edad, nq(4) eststo: reg y D##i.q_edad, vce(robust) margins D#q_edad marginsplot, title(&quot;Heterogeneidad por cuartiles de edad&quot;) graph export &quot;margins_qedad.pdf&quot;, replace üß™ Ejercicios Aleatorizaci√≥n (Bernoulli y estratos) Con tu data.dta, genera D con p=0.5 usando runiform(). Repite p=0.3. Crea estratos por mujer √ó programa y asigna 50/50 exacto por estrato. randtreat avanzado Asigna 3 brazos (T1/T2/C) con proporciones 0.4/0.4/0.2 y estratos mujer √ó programa. Resuelve misfits con misfits(wstrata) y reporta conteos por estrato. Balance Corre difmedias $X, by(D) y exporta a Table_Balance_raw.xlsx. Estima D ~ X (LPM/logit/probit) y reporta el test conjunto. Interpreta: ¬øhay evidencia de desbalance? Efecto del tratamiento Estima \\(Y\\sim D\\) y \\(Y\\sim D+X\\) con SE robustas. Compara \\(\\hat\\tau\\) y sus SE entre modelos; discute precisi√≥n. Si resultado es binario, interpreta en puntos porcentuales. Heterogeneidad Estima \\(Y\\sim D\\times \\text{mujer}\\) y reporta margins. Estima \\(Y\\sim D\\times \\text{libros}\\), grafica marginsplot y comenta el perfil. Bonus (opcional): 6. Repite la estimaci√≥n con SE cluster suponiendo que la asignaci√≥n fue por escuela. Discute diferencias con SE robustas. DESCARGA LOS DOCUMENTOS Descargar Stata do file: Descargar Stata Descargar R script: Descargar R Descargar Phyton Notebook: Descargar Phyton Descarga los Datos (En esta clase usamos la base real data.dta con columnas: id, resultado, grupo, edad, genero, programa, libros.) "],["c√°lculos-de-poder-estad√≠stico-en-stata.html", "Capitulo 7 C√°lculos de Poder Estad√≠stico en Stata Introducci√≥n Sin controles Incorporando controles Tama√±o de muestra con cumplimiento parcial (take-up) Dise√±os por conglomerados o grupos Estad√≠sticas descriptivas Comparaci√≥n de medias Estimador DID paso a paso Usando el comando diff Implementaci√≥n con regresiones Extensi√≥n con panel Interpretaci√≥n", " Capitulo 7 C√°lculos de Poder Estad√≠stico en Stata Introducci√≥n En esta clase trabajaremos con el comando power de Stata para calcular tama√±os de muestra, efectos m√≠nimos detectables (MDE) y explorar c√≥mo cambian estos c√°lculos cuando incorporamos controles consideramos cumplimiento parcial o dise√±amos experimentos aleatorizados por conglomerados. Usaremos el do-file proporcionado y desglosaremos cada secci√≥n con su explicaci√≥n y las f√≥rmulas subyacentes. Nos basamos en la documentaci√≥n oficial de Stata sobre el comando power: Stata Power and Sample Size Reference Manual. y el do file de Poverty Action Lab desarrollado por Sabhya Gupta with input from Jack Cavanagh, Maya Duru, Mike Gibson, Sarah Kopperud, and Chris Udry: Poverty Action Lab - Power Calculations in Stata. Super recomendado leer el manual y el do file para entender todos los detalles. Sin controles Tama√±o de muestra para un efecto dado La primera secci√≥n calcula el tama√±o de muestra requerido para detectar un efecto espec√≠fico. Se define el poder deseado, la raz√≥n de asignaci√≥n entre tratamiento y control (\\(nratio\\)), el nivel de significancia \\(\\alpha\\), y se calcula la media (\\(\\bar{Y}\\)) y la desviaci√≥n est√°ndar (\\(s\\)) de la variable de inter√©s. local power = 0.8 // Poder deseado local nratio = 1 // Raz√≥n N2/N1 (1 = tama√±os iguales) local alpha = 0.05 // Nivel de significancia // Calcular media y desviaci√≥n est√°ndar del outcome sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline= `r(mean)&#39; // Definir el efecto como 0.3 desviaciones est√°ndar local effect = `sd&#39;*0.3 local treat = `baseline&#39; + `effect&#39; // Calcular tama√±o de muestra para detectar ese efecto power twomeans `baseline&#39; `treat&#39;, power(`power&#39;) sd(`sd&#39;) nratio(`nratio&#39;) table // Calcular tama√±os de muestra para un rango de efectos posibles con 4870 observaciones power twomeans `baseline&#39;, power(`power&#39;) sd(`sd&#39;) nratio(`nratio&#39;) n(4870) table F√≥rmula utilizada: Para una prueba bilateral de igualdad de medias con varianzas iguales (\\(\\sigma_1 = \\sigma_2\\)), el tama√±o de muestra total \\(N\\) requerido para detectar una diferencia \\(\\delta = \\mu_2 - \\mu_1\\) con poder \\(1-\\beta\\) y nivel \\(\\alpha\\) es: \\[ N = 2 \\times \\frac{\\bigl(z_{1-\\alpha/2} + z_{1-\\beta}\\bigr)^2\\,\\sigma^2}{\\delta^2}, \\] donde \\(\\sigma\\) es la desviaci√≥n est√°ndar com√∫n. En el c√≥digo, definimos \\(\\delta = 0.3 \\times s\\) y llamamos a power twomeans para que Stata resuelva \\(N\\) usando esta f√≥rmula. Al final, convertimos el efecto a un valor redondeado y extraemos el tama√±o de muestra calculado: local effect = round(`effect&#39;,0.0001) local samplesize= r(N) // Mensaje explicativo di as error &quot;La muestra requerida es `samplesize&#39; para detectar un efecto de `effect&#39; con una probabilidad de `power&#39; si el efecto es verdadero y nratio=`nratio&#39;&quot; A continuaci√≥n se exploran diferentes escenarios variando el efecto o la desviaci√≥n est√°ndar: // Variar el tama√±o del efecto (diff) y ver c√≥mo cambia el N power twomeans `baseline&#39;, power(`power&#39;) sd(`sd&#39;) nratio(`nratio&#39;) diff(0.1(0.15)2) table // Variar la desviaci√≥n est√°ndar de 0.5 a 2 en pasos de 0.1 power twomeans `baseline&#39; `treat&#39;, power(`power&#39;) sd(0.5(0.1)2) nratio(`nratio&#39;) table Estas tablas permiten comparar c√≥mo afectan los cambios en \\(\\delta\\) o en \\(\\sigma\\) al tama√±o de muestra requerido. Efecto m√≠nimo detectable (MDE) para un N dado En esta secci√≥n se fija el tama√±o de muestra total \\(N\\) y se calcula el efecto m√≠nimo detectable (\\(\\delta_{\\min}\\)). local power = 0.8 local nratio = 1 local alpha = 0.05 local N = _N // N√∫mero total de observaciones del dataset actual quietly sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; // Calcular el MDE dado N power twomeans `baseline&#39;, n(`N&#39;) power(`power&#39;) sd(`sd&#39;) nratio(`nratio&#39;) table local mde = round(`r(delta)&#39;,0.0001) // Mensaje explicativo di as error &quot;El efecto m√≠nimo detectable es `mde&#39; dado un tama√±o de muestra `N&#39;, nratio=`nratio&#39; y poder=`power&#39;&quot; F√≥rmula utilizada: Con \\(N\\) fijo y asignaci√≥n balanceada (\\(n_1=n_2=N/2\\)), el efecto m√≠nimo detectable es: \\[ \\delta_{\\min} = \\bigl(z_{1-\\alpha/2} + z_{1-\\beta}\\bigr)\\, \\sigma\\, \\sqrt{\\frac{2}{N}}. \\] El c√≥digo muestra c√≥mo var√≠a el MDE al modificar el tama√±o de muestra o la raz√≥n de asignaci√≥n: // Cambiar N de 10¬†000 a 20¬†000 en pasos de 2¬†000 power twomeans `baseline&#39;, power(`power&#39;) sd(`sd&#39;) n(10000(2000)20000) nratio(`nratio&#39;) table // Cambiar la raz√≥n de tratados a controles power twomeans `baseline&#39;, n(`N&#39;) power(`power&#39;) sd(`sd&#39;) nratio(1(-0.2)0.1) table Una disminuci√≥n en nratio implica asignar una proporci√≥n mayor al grupo de control, lo que en general reduce el poder y aumenta el MDE. MDE para un N dado con variable binaria Cuando el resultado es binario (proporci√≥n de √©xitos), se utiliza el comando power twoproportions. global outcome2 desn_cr // Variable binaria local power = 0.8 local nratio = 1 local alpha = 0.05 local N = _N quietly sum $outcome2 if !missing($outcome2) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; // Ejemplo: comparar una proporci√≥n de 0.08 frente a un rango de proporciones alternativas power twoproportions 0.08 (0.01(0.005)0.1), power(0.8 0.9) graph local mde = round(`r(delta)&#39;,0.0001) F√≥rmula utilizada: Para comparar dos proporciones \\(p_1\\) y \\(p_2\\) con tama√±o de muestra \\(n\\) por grupo, el tama√±o de muestra necesario es: \\[ n = \\frac{\\bigl(z_{1-\\alpha/2} + z_{1-\\beta}\\bigr)^2\\bigl[ p_1(1 - p_1) + p_2(1 - p_2) \\bigr]}{(p_1 - p_2)^2}, \\] y el MDE se obtiene despejando \\(|p_1 - p_2|\\) de esta expresi√≥n. Incorporando controles Para aumentar el poder, es com√∫n incluir covariables que expliquen parte de la variabilidad del resultado. Esto reduce la desviaci√≥n est√°ndar residual y permite detectar efectos m√°s peque√±os. Tama√±o de muestra para un efecto dado con covariables local power = 0.8 local nratio = 1 local alpha = 0.05 local covariates $X // Variables de control local number_covariates: word count `covariates&#39; // Ajustar el outcome por las covariables regress $outcome `covariates&#39; local res_sd = round(sqrt(`e(rss)&#39;/`e(df_r)&#39;), 0.0001) // Desviaci√≥n est√°ndar residual quietly sum $outcome if !missing($outcome) local baseline = `r(mean)&#39; local sd = `r(sd)&#39; local effect_cov = `sd&#39; * 0.3 local treat = `baseline&#39; + `effect_cov&#39; // Calcular tama√±o de muestra usando la desviaci√≥n est√°ndar residual power twomeans `baseline&#39; `treat&#39;, power(`power&#39;) sd(`res_sd&#39;) nratio(`nratio&#39;) alpha(`alpha&#39;) table local effect_cov = round(`effect_cov&#39;, 0.0001) local samplesize_cov = `r(N)&#39; di as error &quot;Se necesita un tama√±o de muestra de `samplesize_cov&#39; para detectar un efecto de `effect_cov&#39; con poder=`power&#39; y desviaci√≥n residual=`res_sd&#39; dado nratio=`nratio&#39;&quot; La desviaci√≥n residual reemplaza a \\(\\sigma\\) en la f√≥rmula de tama√±o de muestra: \\[ N = 2 \\times \\frac{\\bigl(z_{1-\\alpha/2}+z_{1-\\beta}\\bigr)^2\\,\\sigma_{\\text{res}}^2}{\\delta^2}. \\] MDE para un N dado con covariables local power = 0.8 local nratio = 1 local alpha = 0.05 local N_cov = _N // Tama√±o de muestra total // Ajustar el outcome por las covariables regress $outcome `covariates&#39; local res_sd = round(sqrt(`e(rss)&#39;/`e(df_r)&#39;), 0.0001) quietly sum $outcome if !missing($outcome) local baseline = `r(mean)&#39; // Calcular MDE con la desviaci√≥n residual power twomeans `baseline&#39;, n(`N_cov&#39;) power(`power&#39;) sd(`res_sd&#39;) nratio(`nratio&#39;) alpha(`alpha&#39;) table local mde_cov = round(`r(delta)&#39;, 0.0001) di as error &quot;El MDE es `mde_cov&#39; dado N=`N_cov&#39;, nratio=`nratio&#39;, poder=`power&#39; y desviaci√≥n residual=`res_sd&#39;&quot; Tama√±o de muestra con cumplimiento parcial (take-up) Cuando no todos los asignados al tratamiento lo reciben (o algunos controles s√≠ lo reciben), el efecto observable se reduce. El efecto ajustado es el efecto real multiplicado por la diferencia de tasas de participaci√≥n entre grupos: \\[ \\delta_{\\text{efectivo}} = \\delta \\times (\\pi_{\\text{treat}} - \\pi_{\\text{control}}). \\] local power = 0.8 local nratio = 1 local alpha = 0.05 local takeup_treat = 0.9 local takeup_control = 0.1 quietly sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; local effect_tu = `sd&#39; * 0.3 // Efecto con cumplimiento perfecto local tu = `takeup_treat&#39; - `takeup_control&#39; local effect_tu = `effect_tu&#39; * `tu&#39; // Efecto ajustado por cumplimiento local treat_tu = `baseline&#39; + `effect_tu&#39; power twomeans `baseline&#39; `treat_tu&#39;, power(`power&#39;) sd(`sd&#39;) nratio(`nratio&#39;) table local samplesize_tu = `r(N)&#39; local effect_tu = round(`effect_tu&#39;, 0.01) di as error &quot;Se necesita una muestra de `samplesize_tu&#39; para detectar un efecto de `effect_tu&#39; con poder=`power&#39; si nratio=`nratio&#39;&quot; Dise√±os por conglomerados o grupos Cuando la unidad de aleatorizaci√≥n es un grupo (por ejemplo, escuelas), el c√°lculo de poder debe ajustarse por la correlaci√≥n intra-grupo. Se introduce el ICC (\\(\\rho\\)) y el efecto de dise√±o \\(DE = 1 + \\rho(M-1)\\), donde \\(M\\) es el tama√±o del cl√∫ster. N√∫mero de cl√∫steres para un efecto y tama√±o de cl√∫ster dados global cluster_var educa_jefe // Variable de conglomerado local power = 0.8 local nratio = 1 local alpha = 0.05 quietly sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; local cluster_size_control = 50 local mratio = 1 // Raz√≥n M2/M1 local kratio = 1 // Raz√≥n K2/K1 local effect_cluster = `sd&#39; * 0.3 local treat = `baseline&#39; + `effect_cluster&#39; loneway $outcome $cluster_var // Obtener ICC local rho = `r(rho)&#39; // Calcular n√∫mero de cl√∫steres necesarios power twomeans `baseline&#39; `treat&#39;, cluster m1(`cluster_size_control&#39;) mratio(`mratio&#39;) kratio(`kratio&#39;) power(`power&#39;) sd(`sd&#39;) rho(`rho&#39;) alpha(`alpha&#39;) table local effect_cluster = round(`effect_cluster&#39;,0.0001) local n_clus_t = `r(K2)&#39; local n_clus_c = `r(K1)&#39; di as error &quot;Se necesitan `n_clus_c&#39; cl√∫steres de control y `n_clus_t&#39; de tratamiento para detectar un efecto de `effect_cluster&#39; con poder=`power&#39; y tama√±o de cl√∫ster=`cluster_size_control&#39;&quot; F√≥rmula utilizada: Con tama√±os de cl√∫ster \\(M_1\\) y \\(M_2\\) fijos, y \\(\\delta\\) el efecto esperado, el n√∫mero de cl√∫steres de control \\(K_1\\) se calcula como: \\[ K_1 = \\frac{\\bigl(z_{1-\\alpha/2}+z_{1-\\beta}\\bigr)^2}{\\delta^2} \\left( \\frac{\\sigma_1^2 DE_1}{M_1} + \\frac{\\sigma_2^2 DE_2}{M_2 R_k} \\right), \\] donde \\(DE_j = 1 + \\rho (M_j - 1)\\) y \\(R_k = K_2/K_1\\). Tama√±o de cl√∫ster para un n√∫mero dado de cl√∫steres local power = 0.8 local nratio = 1 local alpha = 0.05 quietly sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; bysort $cluster_var: gen control_cluster = _n==1 count if control_cluster &amp; D == 0 local num_clusters_control = `r(N)&#39; local kratio = 1 local effect_cluster = `sd&#39; * 0.3 local treat = `baseline&#39; + `effect_cluster&#39; loneway $outcome $cluster_var local rho = `r(rho)&#39; power twomeans `baseline&#39; `treat&#39;, cluster k1(`num_clusters_control&#39;) kratio(`kratio&#39;) power(`power&#39;) sd(`sd&#39;) rho(`rho&#39;) local clus_size_t = `r(M2)&#39; local clus_size_c = `r(M1)&#39; di as error &quot;El tama√±o m√≠nimo de cada cl√∫ster debe ser `clus_size_c&#39; en control y `clus_size_t&#39; en tratamiento para detectar un efecto de `effect_cluster&#39;&quot; drop control_cluster MDE para un tama√±o de cl√∫ster y n√∫mero de cl√∫steres dados local power = 0.8 local nratio = 1 local alpha = 0.05 quietly sum $outcome if !missing($outcome) local sd = `r(sd)&#39; local baseline = `r(mean)&#39; bysort $cluster_var: gen control_cluster = _n==1 count if control_cluster &amp; D == 0 local num_clusters_control = `r(N)&#39; local kratio = 1 local cluster_size_control = 50 local mratio = 1 loneway $outcome $cluster_var local rho = `r(rho)&#39; power twomeans `baseline&#39;, cluster k1(`num_clusters_control&#39;) kratio(`kratio&#39;) mratio(`mratio&#39;) m1(`cluster_size_control&#39;) power(`power&#39;) sd(`sd&#39;) rho(`rho&#39;) alpha(`alpha&#39;) table local mde_cluster = round(`r(delta)&#39;, 0.0001) di as error &quot;El MDE es `mde_cluster&#39; dado `num_clusters_control&#39; cl√∫steres de control, tama√±o de cl√∫ster=`cluster_size_control&#39; y kratio=`kratio&#39;&quot; drop control_cluster cap log close En un dise√±o por conglomerados, el MDE se calcula como: \\[ |\\delta| = \\bigl(z_{1-\\alpha/2}+z_{1-\\beta}\\bigr)\\,\\sigma_D, \\] donde \\(\\sigma_D = \\sqrt{\\sigma_1^2 DE_1/n_1 + \\sigma_2^2 DE_2/n_2}\\). ## DESCARGA LOS DOCUMENTOS {-} **Descargar Stata do file**: [Descargar Stata](https://raw.githubusercontent.com/adiazescobar/libro_cortes/main/dofile/Clase0_StataBasics/clase0_stata.do) **Descargar R script**: [Descargar R](https://raw.githubusercontent.com/adiazescobar/libro_cortes/main/dofile/Clase0_StataBasics/clase0_R.R) **Descargar Phyton Notebook**: [Descargar Phyton](https://raw.githubusercontent.com/adiazescobar/libro_cortes/main/dofile/Clase0_StataBasics/clase0_phyton.ipynb) [![Abrir en Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/adiazescobar/libro_cortes/blob/main/dofile/Clase0_StataBasics/clase0_phyton.ipynb) **Descarga los Datos** [Descargar Datos](https://raw.githubusercontent.com/adiazescobar/libro_cortes/main/dofile/Clase0_StataBasics/hh_98.dta) --- &lt;!--chapter:end:07-POWER.Rmd--&gt; # Diferencias en Diferencias {-} \\::: {.boxinfo} **üéØ Objetivos de la clase** * Entender la l√≥gica detr√°s del estimador **Difference-in-Differences (DID)**. * Analizar estad√≠sticamente la evoluci√≥n de una variable de resultado para grupos de **tratamiento** y **control** en dos periodos de tiempo. * Implementar DID en **Stata** de tres formas: 1. C√°lculo manual paso a paso. 2. Usando el comando `diff`. 3. Mediante regresiones. \\::: --- ## Preparaci√≥n de los datos {-} ```stata clear all set mem 150m capture log close use &quot;datafiles/base3.dta&quot; Verificamos c√≥mo est√°n definidas las variables de tiempo y tratamiento: tab t tab D tab t D La variable de resultado es ha_nchs, el n√∫mero de desviaciones est√°ndar que el ni√±o est√° por encima o por debajo de la media del grupo relevante. En el do-file la llamaremos simplemente y. Estad√≠sticas descriptivas Promedios por periodo y grupo sum y sum y if t==0 sum y if t==1 bysort t: sum y bysort D: sum y bysort D t: sum y table D t, c(mean y sd y) Definimos etiquetas y graficamos: label define t 0 &quot;t=0&quot; 1 &quot;t=1&quot;, replace label value t t label define D 0 &quot;Control&quot; 1 &quot;Tratado&quot;, replace label value D D graph dot y, over(D) by(t) vertical Evoluci√≥n temporal: preserve collapse y, by(t D) twoway (line y t if D==1) (line y t if D==0), /// legend(label(1 &quot;Tratados&quot;) label(2 &quot;Controles&quot;)) restore Comparaci√≥n de medias ttest y if t == 0, by(D) ttest y if t == 1, by(D) Interpretaci√≥n preliminar: Hay una diferencia preexistente entre tratados y controles en el periodo inicial. La diferencia aumenta despu√©s del tratamiento. DID nos permitir√° aislar el efecto neto del tratamiento controlando por diferencias iniciales. Estimador DID paso a paso Definimos los promedios: sum y if D == 0 &amp; t == 0 scalar y_c0 = r(mean) sum y if D == 0 &amp; t == 1 scalar y_c1 = r(mean) sum y if D == 1 &amp; t == 0 scalar y_t0 = r(mean) sum y if D == 1 &amp; t == 1 scalar y_t1 = r(mean) C√°lculo manual del estimador DID: \\[ \\widehat{DD} = \\big( \\bar{Y}_{T,1} - \\bar{Y}_{T,0}\\big) - \\big( \\bar{Y}_{C,1} - \\bar{Y}_{C,0}\\big) \\] scalar DD = (y_t1 - y_t0) - (y_c1 - y_c0) di DD Usando el comando diff ssc inst diff, replace diff y, t(D) p(t) Implementaci√≥n con regresiones El modelo DID se puede estimar con una regresi√≥n incluyendo interacci√≥n entre tratamiento y tiempo: \\[ Y_{it} = \\alpha + \\beta D_i + \\gamma t_t + \\delta (D_i \\times t_t) + \\varepsilon_{it} \\] Donde: \\(\\delta\\) es el estimador DID. En Stata: reg y D##t Comparaci√≥n con regresi√≥n simple: reg y D Extensi√≥n con panel Definimos datos de panel y usamos notaci√≥n de diferencias: xtset id t reg D.y D.D Interpretaci√≥n El coeficiente asociado a la interacci√≥n \\(D \\times t\\) captura el efecto causal estimado bajo el supuesto de tendencias paralelas. En este caso, el coeficiente fue 0.18 y significativo, lo que indica que la diferencia en talla para la edad entre tratados y controles aument√≥ en 0.18 desviaciones est√°ndar despu√©s de la aplicaci√≥n del programa. "],["test-de-tendencias-paralelas-y-malos-controles.html", "Capitulo 8 Test de Tendencias Paralelas y Malos Controles El supuesto de Tendencias Paralelas Resultados Potenciales Primeras Diferencias y DID Controles en DID Supuestos y Consistencia Sesgo de Agrupaci√≥n Moraleja Final", " Capitulo 8 Test de Tendencias Paralelas y Malos Controles üéØ Metas de aprendizaje Comprender el supuesto de tendencias paralelas en Diferencias en Diferencias (DID). Entender la diferencia entre buenos y malos controles. Relacionar los resultados potenciales con la validez de las estimaciones. Analizar las implicaciones de usar (o no usar) controles en una regresi√≥n. El supuesto de Tendencias Paralelas El coraz√≥n de la estrategia de Diferencias en Diferencias (DID) es el supuesto de que, en ausencia del tratamiento, la evoluci√≥n de los grupos tratados y de control habr√≠a sido paralela en el tiempo. \\[ Y_{it} = \\alpha + \\beta D_i + \\delta T_t + \\gamma (D_i \\times T_t) + \\varepsilon_{it} \\] donde: - \\(D_i\\): indicador de tratamiento, - \\(T_t\\): indicador de post-tratamiento, - \\(\\gamma\\): estimador DID. El supuesto clave es: \\[ E[Y_{i,t=1}(0) - Y_{i,t=0}(0) \\mid D=1] = E[Y_{i,t=1}(0) - Y_{i,t=0}(0) \\mid D=0] \\] Si esto se cumple, la estimaci√≥n DID es insesgada. Resultados Potenciales Recordemos la notaci√≥n: \\(Y_i(1)\\): resultado del individuo \\(i\\) si recibe tratamiento. \\(Y_i(0)\\): resultado del individuo \\(i\\) si no recibe tratamiento. El ATE se define como: \\[ ATE = E[Y_i(1) - Y_i(0)] \\] En DID, el estimador busca identificar justamente esa diferencia, bajo el supuesto de tendencias paralelas. Primeras Diferencias y DID En primeras diferencias: \\[ \\Delta Y_i = Y_{i,t=1} - Y_{i,t=0} \\] y en DID: \\[ DID = \\big( E[\\Delta Y_i \\mid D=1] - E[\\Delta Y_i \\mid D=0] \\big) \\] Controles en DID Buenos controles Caracter√≠sticas predeterminadas, no afectadas por el tratamiento. Ejemplo: educaci√≥n, experiencia laboral previa, g√©nero, edad. Se pueden incluir para: Mejorar la precisi√≥n de la estimaci√≥n. Aumentar la potencia estad√≠stica. Reducir varianza residual. Definici√≥n formal: Un buen control es toda caracter√≠stica observable que no cambia como consecuencia del tratamiento. Son variables predeterminadas que ayudan a explicar el resultado pero no est√°n mediadas por el programa. Ejemplo informal: Si evaluamos el efecto de un programa de formaci√≥n laboral: - Buen control: nivel educativo alcanzado antes del programa. - Buen control: a√±os de experiencia previa. Malos controles Variables que s√≠ pueden variables de resultados. Incluirlas rompe la interpretaci√≥n causal porque introducen endogeneidad. Al condicionar en una variable que est√° ‚Äúen el camino causal‚Äù, se elimina parte del efecto verdadero. Definici√≥n formal: Un mal control es toda variable que se encuentra dentro del mecanismo causal que conecta el tratamiento con el resultado. Condicionar en ella genera sesgo de post-tratamiento. Ejemplo informal: Siguiendo el programa de formaci√≥n laboral: - Mal control: salario despu√©s de haber recibido la capacitaci√≥n. - Mal control: horas trabajadas despu√©s del programa. - Mal control: sector de empleo obtenido gracias al programa. üëâ Todas estas variables son consecuencias (directas o indirectas) del tratamiento. Si las incluimos como controles, estamos borrando parte del impacto que queremos medir. Implicaciones pr√°cticas Con buenos controles: El coeficiente del DID mantiene interpretaci√≥n causal. Mejora la precisi√≥n de la estimaci√≥n. Con malos controles: El estimador se vuelve inconsistente. Perdemos la interpretaci√≥n causal ‚Üí ya no estamos midiendo el efecto del programa, sino algo condicionado en una consecuencia del mismo. En palabras simples: &gt; ‚ÄúUn buen control aclara la foto, un mal control la distorsiona‚Äù. Supuestos y Consistencia El estimador DID ser√° insesgado si: \\[ E[Y_{i}(0) \\mid D=1, t=1] - E[Y_{i}(0) \\mid D=1, t=0] = E[Y_{i}(0) \\mid D=0, t=1] - E[Y_{i}(0) \\mid D=0, t=0] \\] Si los grupos no siguen tendencias paralelas ‚Üí sesgo. Si incluimos malos controles ‚Üí sesgo adicional. Con buenos controles ‚Üí m√°s precisi√≥n, pero no cambia la interpretaci√≥n causal. Sesgo de Agrupaci√≥n Otro problema com√∫n es el sesgo de agrupaci√≥n, que ocurre cuando: - Se promedian resultados sin respetar la estructura de tratamiento y control. - Se incluyen controles end√≥genos que re-agrupan la variaci√≥n. La moraleja es: üëâ Siempre analizar qu√© variables se incluyen y si cumplen el criterio de ser predeterminadas. Moraleja Final El supuesto de tendencias paralelas es fundamental. Los buenos controles ayudan; los malos controles da√±an. DID se entiende mejor desde los resultados potenciales. La interpretaci√≥n causal depende estrictamente de los supuestos. ‚úçÔ∏è Ejercicio para reflexionar Da un ejemplo de buen control y de mal control en la evaluaci√≥n de un programa de transferencias condicionadas. ¬øPor qu√© incluir el nivel de ingreso post-programa ser√≠a un mal control en DID? ¬øC√≥mo verificar√≠as gr√°ficamente el supuesto de tendencias paralelas antes de correr la regresi√≥n? "],["malos-controles-en-stata.html", "Capitulo 9 Malos Controles en Stata 9.1 Mediador (post-tratamiento) Colisionador 9.2 Gr√°ficos de apoyo 9.3 Resumen pr√°ctico", " Capitulo 9 Malos Controles en Stata üéØ Metas de aprendizaje - Ver por qu√© controlar un mediador (variable post-tratamiento) reduce el coeficiente de \\(D\\) cuando queremos el efecto total. - Entender, con un ejemplo separado y simple, qu√© es un colisionador y por qu√© controlarlo abre un camino espurio que sesga el estimador. - Confirmar con un Mini-Monte Carlo que estos sesgos aparecen en promedio. - Visualizar los resultados con coefplots e histogramas. 9.1 Mediador (post-tratamiento) Idea: \\(D\\) afecta a \\(Y\\). Tambi√©n \\(D\\) afecta una variable \\(M\\) (post-tratamiento), que a su vez afecta \\(Y\\). Si controlas \\(M\\) cuando tu objetivo es el efecto total de \\(D\\) sobre \\(Y\\), ‚Äúle quitas‚Äù al coeficiente la parte del camino \\(D \\rightarrow M \\rightarrow Y\\). Mediador: \\(D \\rightarrow M \\rightarrow Y\\) .node { fill: #fff; stroke: #333; stroke-width: 2px; } .label { font-family: sans-serif; font-size: 14px; fill: #111; dominant-baseline: middle; text-anchor: middle; } .edge { stroke: #333; stroke-width: 2px; fill: none; marker-end: url(#arrow); } D M Y U Nota: Si tu par√°metro es el efecto total de D sobre Y, no controles M. ******************************************************************************** * SOLO MEDIADOR: versi√≥n simple y did√°ctica ******************************************************************************** clear all set more off set seed 2468 set obs 50000 gen D = (runiform()&lt;0.5) local rho = .30 matrix C = (1, `rho&#39; \\ `rho&#39;, 1) drawnorm eY eM, corr(C) replace eY = 4*eY gen Y_0 = 1 + eY gen Y_1 = 3 + eY gen Y = D*Y_1 + (1-D)*Y_0 replace eM = 4*eM gen M_0 = 1 + eM gen M_1 = 4 + eM gen M = D*M_1 + (1-D)*M_0 reg Y D reg Y D M capture program drop mc_mediador program define mc_mediador, rclass clear set obs 3000 gen D = (runiform()&lt;0.5) matrix C = (1, .30 \\ .30, 1) drawnorm eY eM, corr(C) replace eY = 4*eY replace eM = 4*eM gen Y_0 = 1 + eY gen Y_1 = 3 + eY gen Y = D*Y_1 + (1-D)*Y_0 gen M_0 = 1 + eM gen M_1 = 4 + eM gen M = D*M_1 + (1-D)*M_0 qui reg Y D return scalar b_total = _b[D] qui reg Y D M return scalar b_directo = _b[D] end simulate b_total=r(b_total) b_directo=r(b_directo), reps(300): mc_mediador sum b_total b_directo Lectura esperada: reg Y D recupera el efecto total. reg Y D M da solo el efecto directo, m√°s peque√±o. coefplot (reg Y D) (reg Y D M), keep(D) /// xline(0) drop(_cons) /// legend(order(1 &quot;Total&quot; 2 &quot;Directo (con M)&quot;)) /// title(&quot;Mediador: coeficiente de D&quot;) Colisionador Idea: \\(U\\) afecta \\(Y\\). \\(C\\) es causado por \\(D\\) y por \\(U\\). Si controlamos \\(C\\), se abre el camino \\(D \\leftrightarrow U \\rightarrow Y\\). .node { fill: #fff; stroke: #333; stroke-width: 2px; } .label { font-family: sans-serif; font-size: 14px; fill: #111; dominant-baseline: middle; text-anchor: middle; } .edge { stroke: #333; stroke-width: 2px; fill: none; marker-end: url(#arrow2); } D C U Y Nota: Controlar C abre el camino D ‚ü∑ U ‚Üí Y y sesga el efecto de D. ******************************************************************************** * COLISIONADOR: ******************************************************************************** clear set more off set seed 2468 set obs 50000 gen U = rnormal() gen eC = rnormal() gen eY = rnormal() gen D = (runiform()&lt;0.5) gen C = 0.7*D + 0.7*U + eC gen Y = 2 + 2.0*D + 1.0*U + eY reg Y D // Benchmark correcto reg Y D C // Sesgado por controlar colisionador --- ## Mini-Monte Carlo: Colisionador ```stata ******************************************************************************** * MONTE CARLO: Colisionador ******************************************************************************** capture program drop mc_colisionador program define mc_colisionador, rclass clear set obs 3000 gen U = rnormal() gen eC = rnormal() gen eY = rnormal() gen D = (runiform()&lt;0.5) gen C = 0.7*D + 0.7*U + eC gen Y = 2 + 2.0*D + 1.0*U + eY qui reg Y D return scalar b_bench = _b[D] qui reg Y D C return scalar b_conC = _b[D] end simulate b_bench=r(b_bench) b_conC=r(b_conC), reps(300): mc_colisionador sum b_bench b_conC 9.2 Gr√°ficos de apoyo 9.2.1 Coefplot del mediador coefplot (reg Y D) (reg Y D M), keep(D) /// xline(0) drop(_cons) /// legend(order(1 &quot;Total&quot; 2 &quot;Directo (con M)&quot;)) /// title(&quot;Mediador: coeficiente de D&quot;) 9.2.2 Histogramas Monte Carlo * Histogramas lado a lado para mediador twoway (hist b_total, width(.1) color(navy%40)) /// (hist b_directo, width(.1) color(red%40)), /// legend(order(1 &quot;Total&quot; 2 &quot;Directo&quot;)) /// title(&quot;Distribuci√≥n de coef D: con y sin M&quot;) * Histogramas para colisionador twoway (hist b_bench, width(.1) color(green%40)) /// (hist b_conC, width(.1) color(orange%40)), /// legend(order(1 &quot;Benchmark&quot; 2 &quot;Con C&quot;)) /// title(&quot;Distribuci√≥n de coef D: benchmark vs. colisionador&quot;) 9.3 Resumen pr√°ctico Mediador: si buscas el efecto total, no lo controles. Colisionador: nunca lo controles; introduce sesgo espurio. Pre-tratamiento: buenos controles para ganar precisi√≥n. "],["malos-controles-mediador-m-vs-colisionador-c-dags.html", "Malos controles: Mediador (M) vs Colisionador (C) ‚Äî DAGs", " Malos controles: Mediador (M) vs Colisionador (C) ‚Äî DAGs Mediador (M) .node { fill:#fff; stroke:#111; stroke-width:2px; } .label{ font:14px sans-serif; fill:#111; dominant-baseline:middle; text-anchor:middle; } .edge { stroke:#111; stroke-width:2px; fill:none; marker-end:url(#arrowM); } .pill { fill:#fee2e2; stroke:#b91c1c; stroke-width:1.5px; rx:6; ry:6; } .warn { font:12px sans-serif; fill:#b91c1c; } D M Y U No controles M Colisionador (C) .node { fill:#fff; stroke:#111; stroke-width:2px; } .label{ font:14px sans-serif; fill:#111; dominant-baseline:middle; text-anchor:middle; } .edge { stroke:#111; stroke-width:2px; fill:none; marker-end:url(#arrowC); } .pill { fill:#ffedd5; stroke:#b45309; stroke-width:1.5px; rx:6; ry:6; } .warn { font:12px sans-serif; fill:#b45309; } .dash { stroke:#b45309; stroke-width:1.5px; fill:none; stroke-dasharray:4 4; } D C U Y No controles C Condicionar en C abre D ‚ü∑ U ‚Üí Y Aspecto Mediador (M) Colisionador (C) Estructura causal D ‚Üí M ‚Üí Y (y posibles U ‚Üí Y) D ‚Üí C ‚Üê U ‚Üí Y Qu√© ocurre si controlas Condicionas en post-tratamiento ‚áí cambias la poblaci√≥n de comparaci√≥n ‚áí sesgo respecto al efecto total. Abres camino espurio D ‚ü∑ U ‚Üí Y ‚áí sesgo. Frase para clase Si buscas el efecto total de D en Y, no controles M. Nunca controles colisionadores. Ejemplo empleo D=usar redes; M=entrar al sector formal; Y=salario. D=usar redes; C=tama√±o de empresa; U=habilidad; Y=salario. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
